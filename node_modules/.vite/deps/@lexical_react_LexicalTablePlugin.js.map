{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalTablePlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { TableNode, TableCellNode, TableRowNode, INSERT_TABLE_COMMAND, $createTableNodeWithDimensions, $computeTableMapSkipCellCheck, $createTableCellNode, $isTableNode, $getNodeTriplet, $computeTableMap, $isTableRowNode, $isTableCellNode, applyTableHandlers } from '@lexical/table';\nimport { mergeRegister, $insertNodeToNearestRoot, $insertFirst } from '@lexical/utils';\nimport { $isTextNode, COMMAND_PRIORITY_EDITOR, $createParagraphNode, $getNodeByKey } from 'lexical';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction TablePlugin({\n  hasCellMerge = true,\n  hasCellBackgroundColor = true,\n  hasTabHandler = true\n}) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    if (!editor.hasNodes([TableNode, TableCellNode, TableRowNode])) {\n      {\n        throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);\n      }\n    }\n    return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, ({\n      columns,\n      rows,\n      includeHeaders\n    }) => {\n      const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n      $insertNodeToNearestRoot(tableNode);\n      const firstDescendant = tableNode.getFirstDescendant();\n      if ($isTextNode(firstDescendant)) {\n        firstDescendant.select();\n      }\n      return true;\n    }, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, node => {\n      const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n      const maxRowLength = gridMap.reduce((curLength, row) => {\n        return Math.max(curLength, row.length);\n      }, 0);\n      const rowNodes = node.getChildren();\n      for (let i = 0; i < gridMap.length; ++i) {\n        const rowNode = rowNodes[i];\n        if (!rowNode) {\n          continue;\n        }\n        const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n        if (rowLength === maxRowLength) {\n          continue;\n        }\n        for (let j = rowLength; j < maxRowLength; ++j) {\n          // TODO: inherit header state from another header or body\n          const newCell = $createTableCellNode(0);\n          newCell.append($createParagraphNode());\n          rowNode.append(newCell);\n        }\n      }\n    }));\n  }, [editor]);\n  useEffect(() => {\n    const tableSelections = new Map();\n    const initializeTableNode = (tableNode, nodeKey, dom) => {\n      const tableElement = dom;\n      const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n      tableSelections.set(nodeKey, [tableSelection, tableElement]);\n    };\n    const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        if (mutation === 'created' || mutation === 'updated') {\n          const tableSelection = tableSelections.get(nodeKey);\n          const dom = editor.getElementByKey(nodeKey);\n          if (!(tableSelection && dom === tableSelection[1])) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            if (tableSelection) {\n              tableSelection[0].removeListeners();\n              tableSelections.delete(nodeKey);\n            }\n            if (dom !== null) {\n              // Create a new TableObserver\n              editor.getEditorState().read(() => {\n                const tableNode = $getNodeByKey(nodeKey);\n                if ($isTableNode(tableNode)) {\n                  initializeTableNode(tableNode, nodeKey, dom);\n                }\n              });\n            }\n          }\n        } else if (mutation === 'destroyed') {\n          const tableSelection = tableSelections.get(nodeKey);\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      skipInitialization: false\n    });\n    return () => {\n      unregisterMutationListener();\n      // Hook might be called multiple times so cleaning up tables listeners as well,\n      // as it'll be reinitialized during recurring call\n      for (const [, [tableSelection]] of tableSelections) {\n        tableSelection.removeListeners();\n      }\n    };\n  }, [editor, hasTabHandler]);\n\n  // Unmerge cells when the feature isn't enabled\n  useEffect(() => {\n    if (hasCellMerge) {\n      return;\n    }\n    return editor.registerNodeTransform(TableCellNode, node => {\n      if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n        // When we have rowSpan we have to map the entire Table to understand where the new Cells\n        // fit best; let's analyze all Cells at once to save us from further transform iterations\n        const [,, gridNode] = $getNodeTriplet(node);\n        const [gridMap] = $computeTableMap(gridNode, node, node);\n        // TODO this function expects Tables to be normalized. Look into this once it exists\n        const rowsCount = gridMap.length;\n        const columnsCount = gridMap[0].length;\n        let row = gridNode.getFirstChild();\n        if (!$isTableRowNode(row)) {\n          throw Error(`Expected TableNode first child to be a RowNode`);\n        }\n        const unmerged = [];\n        for (let i = 0; i < rowsCount; i++) {\n          if (i !== 0) {\n            row = row.getNextSibling();\n            if (!$isTableRowNode(row)) {\n              throw Error(`Expected TableNode first child to be a RowNode`);\n            }\n          }\n          let lastRowCell = null;\n          for (let j = 0; j < columnsCount; j++) {\n            const cellMap = gridMap[i][j];\n            const cell = cellMap.cell;\n            if (cellMap.startRow === i && cellMap.startColumn === j) {\n              lastRowCell = cell;\n              unmerged.push(cell);\n            } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n              if (!$isTableCellNode(cell)) {\n                throw Error(`Expected TableNode cell to be a TableCellNode`);\n              }\n              const newCell = $createTableCellNode(cell.__headerState);\n              if (lastRowCell !== null) {\n                lastRowCell.insertAfter(newCell);\n              } else {\n                $insertFirst(row, newCell);\n              }\n            }\n          }\n        }\n        for (const cell of unmerged) {\n          cell.setColSpan(1);\n          cell.setRowSpan(1);\n        }\n      }\n    });\n  }, [editor, hasCellMerge]);\n\n  // Remove cell background color when feature is disabled\n  useEffect(() => {\n    if (hasCellBackgroundColor) {\n      return;\n    }\n    return editor.registerNodeTransform(TableCellNode, node => {\n      if (node.getBackgroundColor() !== null) {\n        node.setBackgroundColor(null);\n      }\n    });\n  }, [editor, hasCellBackgroundColor, hasCellMerge]);\n  return null;\n}\n\nexport { TablePlugin };\n"],
  "mappings": "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",
  "names": []
}
