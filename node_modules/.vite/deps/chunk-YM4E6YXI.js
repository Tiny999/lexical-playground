import {
  $getNearestNodeOfType,
  addClassNamesToElement,
  mergeRegister,
  removeClassNamesFromElement
} from "./chunk-VPCBVKHR.js";
import {
  $applyNodeReplacement,
  $createParagraphNode,
  $createTextNode,
  $getSelection,
  $isElementNode,
  $isLeafNode,
  $isParagraphNode,
  $isRangeSelection,
  $isRootOrShadowRoot,
  COMMAND_PRIORITY_LOW,
  ElementNode,
  INSERT_PARAGRAPH_COMMAND,
  createCommand,
  isHTMLElement
} from "./chunk-CVCL6TEU.js";

// node_modules/@lexical/list/LexicalList.dev.mjs
function $getListDepth(listNode) {
  let depth = 1;
  let parent = listNode.getParent();
  while (parent != null) {
    if ($isListItemNode(parent)) {
      const parentList = parent.getParent();
      if ($isListNode(parentList)) {
        depth++;
        parent = parentList.getParent();
        continue;
      }
      {
        throw Error(`A ListItemNode must have a ListNode for a parent.`);
      }
    }
    return depth;
  }
  return depth;
}
function $getTopListNode(listItem) {
  let list = listItem.getParent();
  if (!$isListNode(list)) {
    {
      throw Error(`A ListItemNode must have a ListNode for a parent.`);
    }
  }
  let parent = list;
  while (parent !== null) {
    parent = parent.getParent();
    if ($isListNode(parent)) {
      list = parent;
    }
  }
  return list;
}
function $getAllListItems(node) {
  let listItemNodes = [];
  const listChildren = node.getChildren().filter($isListItemNode);
  for (let i = 0; i < listChildren.length; i++) {
    const listItemNode = listChildren[i];
    const firstChild = listItemNode.getFirstChild();
    if ($isListNode(firstChild)) {
      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
    } else {
      listItemNodes.push(listItemNode);
    }
  }
  return listItemNodes;
}
function isNestedListNode(node) {
  return $isListItemNode(node) && $isListNode(node.getFirstChild());
}
function $removeHighestEmptyListParent(sublist) {
  let emptyListPtr = sublist;
  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
    const parent = emptyListPtr.getParent();
    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {
      break;
    }
    emptyListPtr = parent;
  }
  emptyListPtr.remove();
}
function $wrapInListItem(node) {
  const listItemWrapper = $createListItemNode();
  return listItemWrapper.append(node);
}
function $isSelectingEmptyListItem(anchorNode, nodes) {
  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
}
function insertList(editor, listType) {
  editor.update(() => {
    const selection = $getSelection();
    if (selection !== null) {
      const nodes = selection.getNodes();
      if ($isRangeSelection(selection)) {
        const anchorAndFocus = selection.getStartEndPoints();
        if (!(anchorAndFocus !== null)) {
          throw Error(`insertList: anchor should be defined`);
        }
        const [anchor] = anchorAndFocus;
        const anchorNode = anchor.getNode();
        const anchorNodeParent = anchorNode.getParent();
        if ($isSelectingEmptyListItem(anchorNode, nodes)) {
          const list = $createListNode(listType);
          if ($isRootOrShadowRoot(anchorNodeParent)) {
            anchorNode.replace(list);
            const listItem = $createListItemNode();
            if ($isElementNode(anchorNode)) {
              listItem.setFormat(anchorNode.getFormatType());
              listItem.setIndent(anchorNode.getIndent());
            }
            list.append(listItem);
          } else if ($isListItemNode(anchorNode)) {
            const parent = anchorNode.getParentOrThrow();
            append(list, parent.getChildren());
            parent.replace(list);
          }
          return;
        }
      }
      const handled = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {
          $createListOrMerge(node, listType);
          continue;
        }
        if ($isLeafNode(node)) {
          let parent = node.getParent();
          while (parent != null) {
            const parentKey = parent.getKey();
            if ($isListNode(parent)) {
              if (!handled.has(parentKey)) {
                const newListNode = $createListNode(listType);
                append(newListNode, parent.getChildren());
                parent.replace(newListNode);
                handled.add(parentKey);
              }
              break;
            } else {
              const nextParent = parent.getParent();
              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
                handled.add(parentKey);
                $createListOrMerge(parent, listType);
                break;
              }
              parent = nextParent;
            }
          }
        }
      }
    }
  });
}
function append(node, nodesToAppend) {
  node.splice(node.getChildrenSize(), 0, nodesToAppend);
}
function $createListOrMerge(node, listType) {
  if ($isListNode(node)) {
    return node;
  }
  const previousSibling = node.getPreviousSibling();
  const nextSibling = node.getNextSibling();
  const listItem = $createListItemNode();
  append(listItem, node.getChildren());
  let targetList;
  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {
    previousSibling.append(listItem);
    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
      append(previousSibling, nextSibling.getChildren());
      nextSibling.remove();
    }
    targetList = previousSibling;
  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {
    nextSibling.getFirstChildOrThrow().insertBefore(listItem);
    targetList = nextSibling;
  } else {
    const list = $createListNode(listType);
    list.append(listItem);
    node.replace(list);
    targetList = list;
  }
  listItem.setFormat(node.getFormatType());
  listItem.setIndent(node.getIndent());
  node.remove();
  return targetList;
}
function mergeLists(list1, list2) {
  const listItem1 = list1.getLastChild();
  const listItem2 = list2.getFirstChild();
  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
    listItem2.remove();
  }
  const toMerge = list2.getChildren();
  if (toMerge.length > 0) {
    list1.append(...toMerge);
  }
  list2.remove();
}
function removeList(editor) {
  editor.update(() => {
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const listNodes = /* @__PURE__ */ new Set();
      const nodes = selection.getNodes();
      const anchorNode = selection.anchor.getNode();
      if ($isSelectingEmptyListItem(anchorNode, nodes)) {
        listNodes.add($getTopListNode(anchorNode));
      } else {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if ($isLeafNode(node)) {
            const listItemNode = $getNearestNodeOfType(node, ListItemNode);
            if (listItemNode != null) {
              listNodes.add($getTopListNode(listItemNode));
            }
          }
        }
      }
      for (const listNode of listNodes) {
        let insertionPoint = listNode;
        const listItems = $getAllListItems(listNode);
        for (const listItemNode of listItems) {
          const paragraph = $createParagraphNode();
          append(paragraph, listItemNode.getChildren());
          insertionPoint.insertAfter(paragraph);
          insertionPoint = paragraph;
          if (listItemNode.__key === selection.anchor.key) {
            selection.anchor.set(paragraph.getKey(), 0, "element");
          }
          if (listItemNode.__key === selection.focus.key) {
            selection.focus.set(paragraph.getKey(), 0, "element");
          }
          listItemNode.remove();
        }
        listNode.remove();
      }
    }
  });
}
function updateChildrenListItemValue(list) {
  const isNotChecklist = list.getListType() !== "check";
  let value = list.getStart();
  for (const child of list.getChildren()) {
    if ($isListItemNode(child)) {
      if (child.getValue() !== value) {
        child.setValue(value);
      }
      if (isNotChecklist && child.getLatest().__checked != null) {
        child.setChecked(void 0);
      }
      if (!$isListNode(child.getFirstChild())) {
        value++;
      }
    }
  }
}
function mergeNextSiblingListIfSameType(list) {
  const nextSibling = list.getNextSibling();
  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {
    mergeLists(list, nextSibling);
  }
}
function $handleIndent(listItemNode) {
  const removed = /* @__PURE__ */ new Set();
  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
    return;
  }
  const parent = listItemNode.getParent();
  const nextSibling = listItemNode.getNextSibling();
  const previousSibling = listItemNode.getPreviousSibling();
  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
      const nextInnerList = nextSibling.getFirstChild();
      if ($isListNode(nextInnerList)) {
        const children = nextInnerList.getChildren();
        append(innerList, children);
        nextSibling.remove();
        removed.add(nextSibling.getKey());
      }
    }
  } else if (isNestedListNode(nextSibling)) {
    const innerList = nextSibling.getFirstChild();
    if ($isListNode(innerList)) {
      const firstChild = innerList.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(listItemNode);
      }
    }
  } else if (isNestedListNode(previousSibling)) {
    const innerList = previousSibling.getFirstChild();
    if ($isListNode(innerList)) {
      innerList.append(listItemNode);
    }
  } else {
    if ($isListNode(parent)) {
      const newListItem = $createListItemNode();
      const newList = $createListNode(parent.getListType());
      newListItem.append(newList);
      newList.append(listItemNode);
      if (previousSibling) {
        previousSibling.insertAfter(newListItem);
      } else if (nextSibling) {
        nextSibling.insertBefore(newListItem);
      } else {
        parent.append(newListItem);
      }
    }
  }
}
function $handleOutdent(listItemNode) {
  if (isNestedListNode(listItemNode)) {
    return;
  }
  const parentList = listItemNode.getParent();
  const grandparentListItem = parentList ? parentList.getParent() : void 0;
  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {
    const firstChild = parentList ? parentList.getFirstChild() : void 0;
    const lastChild = parentList ? parentList.getLastChild() : void 0;
    if (listItemNode.is(firstChild)) {
      grandparentListItem.insertBefore(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else if (listItemNode.is(lastChild)) {
      grandparentListItem.insertAfter(listItemNode);
      if (parentList.isEmpty()) {
        grandparentListItem.remove();
      }
    } else {
      const listType = parentList.getListType();
      const previousSiblingsListItem = $createListItemNode();
      const previousSiblingsList = $createListNode(listType);
      previousSiblingsListItem.append(previousSiblingsList);
      listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
      const nextSiblingsListItem = $createListItemNode();
      const nextSiblingsList = $createListNode(listType);
      nextSiblingsListItem.append(nextSiblingsList);
      append(nextSiblingsList, listItemNode.getNextSiblings());
      grandparentListItem.insertBefore(previousSiblingsListItem);
      grandparentListItem.insertAfter(nextSiblingsListItem);
      grandparentListItem.replace(listItemNode);
    }
  }
}
function $handleListInsertParagraph() {
  const selection = $getSelection();
  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {
    return false;
  }
  const anchor = selection.anchor.getNode();
  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {
    return false;
  }
  const topListNode = $getTopListNode(anchor);
  const parent = anchor.getParent();
  if (!$isListNode(parent)) {
    throw Error(`A ListItemNode must have a ListNode for a parent.`);
  }
  const grandparent = parent.getParent();
  let replacementNode;
  if ($isRootOrShadowRoot(grandparent)) {
    replacementNode = $createParagraphNode();
    topListNode.insertAfter(replacementNode);
  } else if ($isListItemNode(grandparent)) {
    replacementNode = $createListItemNode();
    grandparent.insertAfter(replacementNode);
  } else {
    return false;
  }
  replacementNode.select();
  const nextSiblings = anchor.getNextSiblings();
  if (nextSiblings.length > 0) {
    const newList = $createListNode(parent.getListType());
    if ($isParagraphNode(replacementNode)) {
      replacementNode.insertAfter(newList);
    } else {
      const newListItem = $createListItemNode();
      newListItem.append(newList);
      replacementNode.insertAfter(newListItem);
    }
    nextSiblings.forEach((sibling) => {
      sibling.remove();
      newList.append(sibling);
    });
  }
  $removeHighestEmptyListParent(anchor);
  return true;
}
function normalizeClassNames(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s] of className.matchAll(/\S+/g)) {
        rval.push(s);
      }
    }
  }
  return rval;
}
var ListItemNode = class _ListItemNode extends ElementNode {
  /** @internal */
  /** @internal */
  static getType() {
    return "listitem";
  }
  static clone(node) {
    return new _ListItemNode(node.__value, node.__checked, node.__key);
  }
  constructor(value, checked, key) {
    super(key);
    this.__value = value === void 0 ? 1 : value;
    this.__checked = checked;
  }
  createDOM(config) {
    const element = document.createElement("li");
    const parent = this.getParent();
    if ($isListNode(parent) && parent.getListType() === "check") {
      updateListItemChecked(element, this, null);
    }
    element.value = this.__value;
    $setListItemThemeClassNames(element, config.theme, this);
    return element;
  }
  updateDOM(prevNode, dom, config) {
    const parent = this.getParent();
    if ($isListNode(parent) && parent.getListType() === "check") {
      updateListItemChecked(dom, this, prevNode);
    }
    dom.value = this.__value;
    $setListItemThemeClassNames(dom, config.theme, this);
    return false;
  }
  static transform() {
    return (node) => {
      if (!$isListItemNode(node)) {
        throw Error(`node is not a ListItemNode`);
      }
      if (node.__checked == null) {
        return;
      }
      const parent = node.getParent();
      if ($isListNode(parent)) {
        if (parent.getListType() !== "check" && node.getChecked() != null) {
          node.setChecked(void 0);
        }
      }
    };
  }
  static importDOM() {
    return {
      li: () => ({
        conversion: $convertListItemElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    const node = $createListItemNode();
    node.setChecked(serializedNode.checked);
    node.setValue(serializedNode.value);
    node.setFormat(serializedNode.format);
    node.setDirection(serializedNode.direction);
    return node;
  }
  exportDOM(editor) {
    const element = this.createDOM(editor._config);
    element.style.textAlign = this.getFormatType();
    return {
      element
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      checked: this.getChecked(),
      type: "listitem",
      value: this.getValue(),
      version: 1
    };
  }
  append(...nodes) {
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if ($isElementNode(node) && this.canMergeWith(node)) {
        const children = node.getChildren();
        this.append(...children);
        node.remove();
      } else {
        super.append(node);
      }
    }
    return this;
  }
  replace(replaceWithNode, includeChildren) {
    if ($isListItemNode(replaceWithNode)) {
      return super.replace(replaceWithNode);
    }
    this.setIndent(0);
    const list = this.getParentOrThrow();
    if (!$isListNode(list)) {
      return replaceWithNode;
    }
    if (list.__first === this.getKey()) {
      list.insertBefore(replaceWithNode);
    } else if (list.__last === this.getKey()) {
      list.insertAfter(replaceWithNode);
    } else {
      const newList = $createListNode(list.getListType());
      let nextSibling = this.getNextSibling();
      while (nextSibling) {
        const nodeToAppend = nextSibling;
        nextSibling = nextSibling.getNextSibling();
        newList.append(nodeToAppend);
      }
      list.insertAfter(replaceWithNode);
      replaceWithNode.insertAfter(newList);
    }
    if (includeChildren) {
      if (!$isElementNode(replaceWithNode)) {
        throw Error(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        replaceWithNode.append(child);
      });
    }
    this.remove();
    if (list.getChildrenSize() === 0) {
      list.remove();
    }
    return replaceWithNode;
  }
  insertAfter(node, restoreSelection = true) {
    const listNode = this.getParentOrThrow();
    if (!$isListNode(listNode)) {
      {
        throw Error(`insertAfter: list node is not parent of list item node`);
      }
    }
    if ($isListItemNode(node)) {
      return super.insertAfter(node, restoreSelection);
    }
    const siblings = this.getNextSiblings();
    listNode.insertAfter(node, restoreSelection);
    if (siblings.length !== 0) {
      const newListNode = $createListNode(listNode.getListType());
      siblings.forEach((sibling) => newListNode.append(sibling));
      node.insertAfter(newListNode, restoreSelection);
    }
    return node;
  }
  remove(preserveEmptyParent) {
    const prevSibling = this.getPreviousSibling();
    const nextSibling = this.getNextSibling();
    super.remove(preserveEmptyParent);
    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
      nextSibling.remove();
    }
  }
  insertNewAfter(_, restoreSelection = true) {
    const newElement = $createListItemNode(this.__checked == null ? void 0 : false);
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart(selection) {
    const paragraph = $createParagraphNode();
    const children = this.getChildren();
    children.forEach((child) => paragraph.append(child));
    const listNode = this.getParentOrThrow();
    const listNodeParent = listNode.getParentOrThrow();
    const isIndented = $isListItemNode(listNodeParent);
    if (listNode.getChildrenSize() === 1) {
      if (isIndented) {
        listNode.remove();
        listNodeParent.select();
      } else {
        listNode.insertBefore(paragraph);
        listNode.remove();
        const anchor = selection.anchor;
        const focus = selection.focus;
        const key = paragraph.getKey();
        if (anchor.type === "element" && anchor.getNode().is(this)) {
          anchor.set(key, anchor.offset, "element");
        }
        if (focus.type === "element" && focus.getNode().is(this)) {
          focus.set(key, focus.offset, "element");
        }
      }
    } else {
      listNode.insertBefore(paragraph);
      this.remove();
    }
    return true;
  }
  getValue() {
    const self = this.getLatest();
    return self.__value;
  }
  setValue(value) {
    const self = this.getWritable();
    self.__value = value;
  }
  getChecked() {
    const self = this.getLatest();
    let listType;
    const parent = this.getParent();
    if ($isListNode(parent)) {
      listType = parent.getListType();
    }
    return listType === "check" ? Boolean(self.__checked) : void 0;
  }
  setChecked(checked) {
    const self = this.getWritable();
    self.__checked = checked;
  }
  toggleChecked() {
    this.setChecked(!this.__checked);
  }
  getIndent() {
    const parent = this.getParent();
    if (parent === null) {
      return this.getLatest().__indent;
    }
    let listNodeParent = parent.getParentOrThrow();
    let indentLevel = 0;
    while ($isListItemNode(listNodeParent)) {
      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
      indentLevel++;
    }
    return indentLevel;
  }
  setIndent(indent) {
    if (!(typeof indent === "number")) {
      throw Error(`Invalid indent value.`);
    }
    indent = Math.floor(indent);
    if (!(indent >= 0)) {
      throw Error(`Indent value must be non-negative.`);
    }
    let currentIndent = this.getIndent();
    while (currentIndent !== indent) {
      if (currentIndent < indent) {
        $handleIndent(this);
        currentIndent++;
      } else {
        $handleOutdent(this);
        currentIndent--;
      }
    }
    return this;
  }
  /** @deprecated @internal */
  canInsertAfter(node) {
    return $isListItemNode(node);
  }
  /** @deprecated @internal */
  canReplaceWith(replacement) {
    return $isListItemNode(replacement);
  }
  canMergeWith(node) {
    return $isParagraphNode(node) || $isListItemNode(node);
  }
  extractWithChild(child, selection) {
    if (!$isRangeSelection(selection)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
  }
  isParentRequired() {
    return true;
  }
  createParentElementNode() {
    return $createListNode("bullet");
  }
  canMergeWhenEmpty() {
    return true;
  }
};
function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  const listItemClassName = listTheme ? listTheme.listitem : void 0;
  let nestedListItemClassName;
  if (listTheme && listTheme.nested) {
    nestedListItemClassName = listTheme.nested.listitem;
  }
  if (listItemClassName !== void 0) {
    classesToAdd.push(...normalizeClassNames(listItemClassName));
  }
  if (listTheme) {
    const parentNode = node.getParent();
    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === "check";
    const checked = node.getChecked();
    if (!isCheckList || checked) {
      classesToRemove.push(listTheme.listitemUnchecked);
    }
    if (!isCheckList || !checked) {
      classesToRemove.push(listTheme.listitemChecked);
    }
    if (isCheckList) {
      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
    }
  }
  if (nestedListItemClassName !== void 0) {
    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);
    if (node.getChildren().some((child) => $isListNode(child))) {
      classesToAdd.push(...nestedListItemClasses);
    } else {
      classesToRemove.push(...nestedListItemClasses);
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement(dom, ...classesToAdd);
  }
}
function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
  if ($isListNode(listItemNode.getFirstChild())) {
    dom.removeAttribute("role");
    dom.removeAttribute("tabIndex");
    dom.removeAttribute("aria-checked");
  } else {
    dom.setAttribute("role", "checkbox");
    dom.setAttribute("tabIndex", "-1");
    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
      dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
    }
  }
}
function $convertListItemElement(domNode) {
  const isGitHubCheckList = domNode.classList.contains("task-list-item");
  if (isGitHubCheckList) {
    for (const child of domNode.children) {
      if (child.tagName === "INPUT") {
        return $convertCheckboxInput(child);
      }
    }
  }
  const ariaCheckedAttr = domNode.getAttribute("aria-checked");
  const checked = ariaCheckedAttr === "true" ? true : ariaCheckedAttr === "false" ? false : void 0;
  return {
    node: $createListItemNode(checked)
  };
}
function $convertCheckboxInput(domNode) {
  const isCheckboxInput = domNode.getAttribute("type") === "checkbox";
  if (!isCheckboxInput) {
    return {
      node: null
    };
  }
  const checked = domNode.hasAttribute("checked");
  return {
    node: $createListItemNode(checked)
  };
}
function $createListItemNode(checked) {
  return $applyNodeReplacement(new ListItemNode(void 0, checked));
}
function $isListItemNode(node) {
  return node instanceof ListItemNode;
}
var ListNode = class _ListNode extends ElementNode {
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "list";
  }
  static clone(node) {
    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
    return new _ListNode(listType, node.__start, node.__key);
  }
  constructor(listType, start, key) {
    super(key);
    const _listType = TAG_TO_LIST_TYPE[listType] || listType;
    this.__listType = _listType;
    this.__tag = _listType === "number" ? "ol" : "ul";
    this.__start = start;
  }
  getTag() {
    return this.__tag;
  }
  setListType(type) {
    const writable = this.getWritable();
    writable.__listType = type;
    writable.__tag = type === "number" ? "ol" : "ul";
  }
  getListType() {
    return this.__listType;
  }
  getStart() {
    return this.__start;
  }
  // View
  createDOM(config, _editor) {
    const tag = this.__tag;
    const dom = document.createElement(tag);
    if (this.__start !== 1) {
      dom.setAttribute("start", String(this.__start));
    }
    dom.__lexicalListType = this.__listType;
    $setListThemeClassNames(dom, config.theme, this);
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    if (prevNode.__tag !== this.__tag) {
      return true;
    }
    $setListThemeClassNames(dom, config.theme, this);
    return false;
  }
  static transform() {
    return (node) => {
      if (!$isListNode(node)) {
        throw Error(`node is not a ListNode`);
      }
      mergeNextSiblingListIfSameType(node);
      updateChildrenListItemValue(node);
    };
  }
  static importDOM() {
    return {
      ol: () => ({
        conversion: $convertListNode,
        priority: 0
      }),
      ul: () => ({
        conversion: $convertListNode,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    const node = $createListNode(serializedNode.listType, serializedNode.start);
    node.setFormat(serializedNode.format);
    node.setIndent(serializedNode.indent);
    node.setDirection(serializedNode.direction);
    return node;
  }
  exportDOM(editor) {
    const element = this.createDOM(editor._config, editor);
    if (element && isHTMLElement(element)) {
      if (this.__start !== 1) {
        element.setAttribute("start", String(this.__start));
      }
      if (this.__listType === "check") {
        element.setAttribute("__lexicalListType", "check");
      }
    }
    return {
      element
    };
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      listType: this.getListType(),
      start: this.getStart(),
      tag: this.getTag(),
      type: "list",
      version: 1
    };
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
  append(...nodesToAppend) {
    for (let i = 0; i < nodesToAppend.length; i++) {
      const currentNode = nodesToAppend[i];
      if ($isListItemNode(currentNode)) {
        super.append(currentNode);
      } else {
        const listItemNode = $createListItemNode();
        if ($isListNode(currentNode)) {
          listItemNode.append(currentNode);
        } else if ($isElementNode(currentNode)) {
          const textNode = $createTextNode(currentNode.getTextContent());
          listItemNode.append(textNode);
        } else {
          listItemNode.append(currentNode);
        }
        super.append(listItemNode);
      }
    }
    return this;
  }
  extractWithChild(child) {
    return $isListItemNode(child);
  }
};
function $setListThemeClassNames(dom, editorThemeClasses, node) {
  const classesToAdd = [];
  const classesToRemove = [];
  const listTheme = editorThemeClasses.list;
  if (listTheme !== void 0) {
    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
    const listDepth = $getListDepth(node) - 1;
    const normalizedListDepth = listDepth % listLevelsClassNames.length;
    const listLevelClassName = listLevelsClassNames[normalizedListDepth];
    const listClassName = listTheme[node.__tag];
    let nestedListClassName;
    const nestedListTheme = listTheme.nested;
    const checklistClassName = listTheme.checklist;
    if (nestedListTheme !== void 0 && nestedListTheme.list) {
      nestedListClassName = nestedListTheme.list;
    }
    if (listClassName !== void 0) {
      classesToAdd.push(listClassName);
    }
    if (checklistClassName !== void 0 && node.__listType === "check") {
      classesToAdd.push(checklistClassName);
    }
    if (listLevelClassName !== void 0) {
      classesToAdd.push(...normalizeClassNames(listLevelClassName));
      for (let i = 0; i < listLevelsClassNames.length; i++) {
        if (i !== normalizedListDepth) {
          classesToRemove.push(node.__tag + i);
        }
      }
    }
    if (nestedListClassName !== void 0) {
      const nestedListItemClasses = normalizeClassNames(nestedListClassName);
      if (listDepth > 1) {
        classesToAdd.push(...nestedListItemClasses);
      } else {
        classesToRemove.push(...nestedListItemClasses);
      }
    }
  }
  if (classesToRemove.length > 0) {
    removeClassNamesFromElement(dom, ...classesToRemove);
  }
  if (classesToAdd.length > 0) {
    addClassNamesToElement(dom, ...classesToAdd);
  }
}
function $normalizeChildren(nodes) {
  const normalizedListItems = [];
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if ($isListItemNode(node)) {
      normalizedListItems.push(node);
      const children = node.getChildren();
      if (children.length > 1) {
        children.forEach((child) => {
          if ($isListNode(child)) {
            normalizedListItems.push($wrapInListItem(child));
          }
        });
      }
    } else {
      normalizedListItems.push($wrapInListItem(node));
    }
  }
  return normalizedListItems;
}
function isDomChecklist(domNode) {
  if (domNode.getAttribute("__lexicallisttype") === "check" || // is github checklist
  domNode.classList.contains("contains-task-list")) {
    return true;
  }
  for (const child of domNode.childNodes) {
    if (isHTMLElement(child) && child.hasAttribute("aria-checked")) {
      return true;
    }
  }
  return false;
}
function $convertListNode(domNode) {
  const nodeName = domNode.nodeName.toLowerCase();
  let node = null;
  if (nodeName === "ol") {
    const start = domNode.start;
    node = $createListNode("number", start);
  } else if (nodeName === "ul") {
    if (isDomChecklist(domNode)) {
      node = $createListNode("check");
    } else {
      node = $createListNode("bullet");
    }
  }
  return {
    after: $normalizeChildren,
    node
  };
}
var TAG_TO_LIST_TYPE = {
  ol: "number",
  ul: "bullet"
};
function $createListNode(listType, start = 1) {
  return $applyNodeReplacement(new ListNode(listType, start));
}
function $isListNode(node) {
  return node instanceof ListNode;
}
var INSERT_UNORDERED_LIST_COMMAND = createCommand("INSERT_UNORDERED_LIST_COMMAND");
var INSERT_ORDERED_LIST_COMMAND = createCommand("INSERT_ORDERED_LIST_COMMAND");
var INSERT_CHECK_LIST_COMMAND = createCommand("INSERT_CHECK_LIST_COMMAND");
var REMOVE_LIST_COMMAND = createCommand("REMOVE_LIST_COMMAND");
function registerList(editor) {
  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {
    insertList(editor, "number");
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {
    insertList(editor, "bullet");
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {
    removeList(editor);
    return true;
  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {
    const hasHandledInsertParagraph = $handleListInsertParagraph();
    if (hasHandledInsertParagraph) {
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_LOW));
  return removeListener;
}

export {
  $getListDepth,
  insertList,
  removeList,
  $handleListInsertParagraph,
  ListItemNode,
  $createListItemNode,
  $isListItemNode,
  ListNode,
  $createListNode,
  $isListNode,
  INSERT_UNORDERED_LIST_COMMAND,
  INSERT_ORDERED_LIST_COMMAND,
  INSERT_CHECK_LIST_COMMAND,
  REMOVE_LIST_COMMAND,
  registerList
};
//# sourceMappingURL=chunk-YM4E6YXI.js.map
