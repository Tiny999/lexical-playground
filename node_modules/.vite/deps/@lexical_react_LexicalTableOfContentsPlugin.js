import {
  $isHeadingNode,
  HeadingNode
} from "./chunk-7KR3ZO5X.js";
import "./chunk-UV775WKF.js";
import {
  useLexicalComposerContext
} from "./chunk-5BMJGEYX.js";
import "./chunk-O6OHZHAK.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  $getNextRightPreorderNode
} from "./chunk-VPCBVKHR.js";
import "./chunk-VD5PEWHI.js";
import {
  $getNodeByKey,
  $getRoot,
  $isElementNode,
  TextNode
} from "./chunk-CVCL6TEU.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@lexical/react/LexicalTableOfContentsPlugin.dev.mjs
var import_react = __toESM(require_react(), 1);
function toEntry(heading) {
  return [heading.getKey(), heading.getTextContent(), heading.getTag()];
}
function $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents) {
  if (newHeading === null) {
    return currentTableOfContents;
  }
  const newEntry = toEntry(newHeading);
  let newTableOfContents = [];
  if (prevHeading === null) {
    if (currentTableOfContents.length > 0 && currentTableOfContents[0][0] === newHeading.__key) {
      return currentTableOfContents;
    }
    newTableOfContents = [newEntry, ...currentTableOfContents];
  } else {
    for (let i = 0; i < currentTableOfContents.length; i++) {
      const key = currentTableOfContents[i][0];
      newTableOfContents.push(currentTableOfContents[i]);
      if (key === prevHeading.getKey() && key !== newHeading.getKey()) {
        if (i + 1 < currentTableOfContents.length && currentTableOfContents[i + 1][0] === newHeading.__key) {
          return currentTableOfContents;
        }
        newTableOfContents.push(newEntry);
      }
    }
  }
  return newTableOfContents;
}
function $deleteHeadingFromTableOfContents(key, currentTableOfContents) {
  const newTableOfContents = [];
  for (const heading of currentTableOfContents) {
    if (heading[0] !== key) {
      newTableOfContents.push(heading);
    }
  }
  return newTableOfContents;
}
function $updateHeadingInTableOfContents(heading, currentTableOfContents) {
  const newTableOfContents = [];
  for (const oldHeading of currentTableOfContents) {
    if (oldHeading[0] === heading.getKey()) {
      newTableOfContents.push(toEntry(heading));
    } else {
      newTableOfContents.push(oldHeading);
    }
  }
  return newTableOfContents;
}
function $updateHeadingPosition(prevHeading, heading, currentTableOfContents) {
  const newTableOfContents = [];
  const newEntry = toEntry(heading);
  if (!prevHeading) {
    newTableOfContents.push(newEntry);
  }
  for (const oldHeading of currentTableOfContents) {
    if (oldHeading[0] === heading.getKey()) {
      continue;
    }
    newTableOfContents.push(oldHeading);
    if (prevHeading && oldHeading[0] === prevHeading.getKey()) {
      newTableOfContents.push(newEntry);
    }
  }
  return newTableOfContents;
}
function $getPreviousHeading(node) {
  let prevHeading = $getNextRightPreorderNode(node);
  while (prevHeading !== null && !$isHeadingNode(prevHeading)) {
    prevHeading = $getNextRightPreorderNode(prevHeading);
  }
  return prevHeading;
}
function TableOfContentsPlugin({
  children
}) {
  const [tableOfContents, setTableOfContents] = (0, import_react.useState)([]);
  const [editor] = useLexicalComposerContext();
  (0, import_react.useEffect)(() => {
    let currentTableOfContents = [];
    editor.getEditorState().read(() => {
      const updateCurrentTableOfContents = (node) => {
        for (const child of node.getChildren()) {
          if ($isHeadingNode(child)) {
            currentTableOfContents.push([child.getKey(), child.getTextContent(), child.getTag()]);
          } else if ($isElementNode(child)) {
            updateCurrentTableOfContents(child);
          }
        }
      };
      updateCurrentTableOfContents($getRoot());
      setTableOfContents(currentTableOfContents);
    });
    const removeRootUpdateListener = editor.registerUpdateListener(({
      editorState,
      dirtyElements
    }) => {
      editorState.read(() => {
        const updateChildHeadings = (node) => {
          for (const child of node.getChildren()) {
            if ($isHeadingNode(child)) {
              const prevHeading = $getPreviousHeading(child);
              currentTableOfContents = $updateHeadingPosition(prevHeading, child, currentTableOfContents);
              setTableOfContents(currentTableOfContents);
            } else if ($isElementNode(child)) {
              updateChildHeadings(child);
            }
          }
        };
        $getRoot().getChildren().forEach((node) => {
          if ($isElementNode(node) && dirtyElements.get(node.__key)) {
            updateChildHeadings(node);
          }
        });
      });
    });
    const removeHeaderMutationListener = editor.registerMutationListener(
      HeadingNode,
      (mutatedNodes) => {
        editor.getEditorState().read(() => {
          for (const [nodeKey, mutation] of mutatedNodes) {
            if (mutation === "created") {
              const newHeading = $getNodeByKey(nodeKey);
              if (newHeading !== null) {
                const prevHeading = $getPreviousHeading(newHeading);
                currentTableOfContents = $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents);
              }
            } else if (mutation === "destroyed") {
              currentTableOfContents = $deleteHeadingFromTableOfContents(nodeKey, currentTableOfContents);
            } else if (mutation === "updated") {
              const newHeading = $getNodeByKey(nodeKey);
              if (newHeading !== null) {
                const prevHeading = $getPreviousHeading(newHeading);
                currentTableOfContents = $updateHeadingPosition(prevHeading, newHeading, currentTableOfContents);
              }
            }
          }
          setTableOfContents(currentTableOfContents);
        });
      },
      // Initialization is handled separately
      {
        skipInitialization: true
      }
    );
    const removeTextNodeMutationListener = editor.registerMutationListener(
      TextNode,
      (mutatedNodes) => {
        editor.getEditorState().read(() => {
          for (const [nodeKey, mutation] of mutatedNodes) {
            if (mutation === "updated") {
              const currNode = $getNodeByKey(nodeKey);
              if (currNode !== null) {
                const parentNode = currNode.getParentOrThrow();
                if ($isHeadingNode(parentNode)) {
                  currentTableOfContents = $updateHeadingInTableOfContents(parentNode, currentTableOfContents);
                  setTableOfContents(currentTableOfContents);
                }
              }
            }
          }
        });
      },
      // Initialization is handled separately
      {
        skipInitialization: true
      }
    );
    return () => {
      removeHeaderMutationListener();
      removeTextNodeMutationListener();
      removeRootUpdateListener();
    };
  }, [editor]);
  return children(tableOfContents, editor);
}
export {
  TableOfContentsPlugin
};
//# sourceMappingURL=@lexical_react_LexicalTableOfContentsPlugin.js.map
