{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalDraggableBlockPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { eventFiles } from '@lexical/rich-text';\nimport { mergeRegister, isHTMLElement, calculateZoomLevel } from '@lexical/utils';\nimport { DRAGOVER_COMMAND, COMMAND_PRIORITY_LOW, DROP_COMMAND, COMMAND_PRIORITY_HIGH, $getNodeByKey, $getNearestNodeFromDOMNode, $getRoot } from 'lexical';\nimport { useRef, useState, useEffect } from 'react';\nimport { createPortal } from 'react-dom';\nimport { jsxs, Fragment, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(x, y) {\n    this._x = x;\n    this._y = y;\n  }\n  get x() {\n    return this._x;\n  }\n  get y() {\n    return this._y;\n  }\n  equals({\n    x,\n    y\n  }) {\n    return this.x === x && this.y === y;\n  }\n  calcDeltaXTo({\n    x\n  }) {\n    return this.x - x;\n  }\n  calcDeltaYTo({\n    y\n  }) {\n    return this.y - y;\n  }\n  calcHorizontalDistanceTo(point) {\n    return Math.abs(this.calcDeltaXTo(point));\n  }\n  calcVerticalDistance(point) {\n    return Math.abs(this.calcDeltaYTo(point));\n  }\n  calcDistanceTo(point) {\n    return Math.sqrt(Math.pow(this.calcDeltaXTo(point), 2) + Math.pow(this.calcDeltaYTo(point), 2));\n  }\n}\nfunction isPoint(x) {\n  return x instanceof Point;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Rectangle {\n  constructor(left, top, right, bottom) {\n    const [physicTop, physicBottom] = top <= bottom ? [top, bottom] : [bottom, top];\n    const [physicLeft, physicRight] = left <= right ? [left, right] : [right, left];\n    this._top = physicTop;\n    this._right = physicRight;\n    this._left = physicLeft;\n    this._bottom = physicBottom;\n  }\n  get top() {\n    return this._top;\n  }\n  get right() {\n    return this._right;\n  }\n  get bottom() {\n    return this._bottom;\n  }\n  get left() {\n    return this._left;\n  }\n  get width() {\n    return Math.abs(this._left - this._right);\n  }\n  get height() {\n    return Math.abs(this._bottom - this._top);\n  }\n  equals({\n    top,\n    left,\n    bottom,\n    right\n  }) {\n    return top === this._top && bottom === this._bottom && left === this._left && right === this._right;\n  }\n  contains(target) {\n    if (isPoint(target)) {\n      const {\n        x,\n        y\n      } = target;\n      const isOnTopSide = y < this._top;\n      const isOnBottomSide = y > this._bottom;\n      const isOnLeftSide = x < this._left;\n      const isOnRightSide = x > this._right;\n      const result = !isOnTopSide && !isOnBottomSide && !isOnLeftSide && !isOnRightSide;\n      return {\n        reason: {\n          isOnBottomSide,\n          isOnLeftSide,\n          isOnRightSide,\n          isOnTopSide\n        },\n        result\n      };\n    } else {\n      const {\n        top,\n        left,\n        bottom,\n        right\n      } = target;\n      return top >= this._top && top <= this._bottom && bottom >= this._top && bottom <= this._bottom && left >= this._left && left <= this._right && right >= this._left && right <= this._right;\n    }\n  }\n  intersectsWith(rect) {\n    const {\n      left: x1,\n      top: y1,\n      width: w1,\n      height: h1\n    } = rect;\n    const {\n      left: x2,\n      top: y2,\n      width: w2,\n      height: h2\n    } = this;\n    const maxX = x1 + w1 >= x2 + w2 ? x1 + w1 : x2 + w2;\n    const maxY = y1 + h1 >= y2 + h2 ? y1 + h1 : y2 + h2;\n    const minX = x1 <= x2 ? x1 : x2;\n    const minY = y1 <= y2 ? y1 : y2;\n    return maxX - minX <= w1 + w2 && maxY - minY <= h1 + h2;\n  }\n  generateNewRect({\n    left = this.left,\n    top = this.top,\n    right = this.right,\n    bottom = this.bottom\n  }) {\n    return new Rectangle(left, top, right, bottom);\n  }\n  static fromLTRB(left, top, right, bottom) {\n    return new Rectangle(left, top, right, bottom);\n  }\n  static fromLWTH(left, width, top, height) {\n    return new Rectangle(left, top, left + width, top + height);\n  }\n  static fromPoints(startPoint, endPoint) {\n    const {\n      y: top,\n      x: left\n    } = startPoint;\n    const {\n      y: bottom,\n      x: right\n    } = endPoint;\n    return Rectangle.fromLTRB(left, top, right, bottom);\n  }\n  static fromDOM(dom) {\n    const {\n      top,\n      width,\n      left,\n      height\n    } = dom.getBoundingClientRect();\n    return Rectangle.fromLWTH(left, width, top, height);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SPACE = 4;\nconst TARGET_LINE_HALF_HEIGHT = 2;\nconst DRAG_DATA_FORMAT = 'application/x-lexical-drag-block';\nconst TEXT_BOX_HORIZONTAL_PADDING = 28;\nconst Downward = 1;\nconst Upward = -1;\nconst Indeterminate = 0;\nlet prevIndex = Infinity;\nfunction getCurrentIndex(keysLength) {\n  if (keysLength === 0) {\n    return Infinity;\n  }\n  if (prevIndex >= 0 && prevIndex < keysLength) {\n    return prevIndex;\n  }\n  return Math.floor(keysLength / 2);\n}\nfunction getTopLevelNodeKeys(editor) {\n  return editor.getEditorState().read(() => $getRoot().getChildrenKeys());\n}\nfunction getCollapsedMargins(elem) {\n  const getMargin = (element, margin) => element ? parseFloat(window.getComputedStyle(element)[margin]) : 0;\n  const {\n    marginTop,\n    marginBottom\n  } = window.getComputedStyle(elem);\n  const prevElemSiblingMarginBottom = getMargin(elem.previousElementSibling, 'marginBottom');\n  const nextElemSiblingMarginTop = getMargin(elem.nextElementSibling, 'marginTop');\n  const collapsedTopMargin = Math.max(parseFloat(marginTop), prevElemSiblingMarginBottom);\n  const collapsedBottomMargin = Math.max(parseFloat(marginBottom), nextElemSiblingMarginTop);\n  return {\n    marginBottom: collapsedBottomMargin,\n    marginTop: collapsedTopMargin\n  };\n}\nfunction getBlockElement(anchorElem, editor, event, useEdgeAsDefault = false) {\n  const anchorElementRect = anchorElem.getBoundingClientRect();\n  const topLevelNodeKeys = getTopLevelNodeKeys(editor);\n  let blockElem = null;\n  editor.getEditorState().read(() => {\n    if (useEdgeAsDefault) {\n      const [firstNode, lastNode] = [editor.getElementByKey(topLevelNodeKeys[0]), editor.getElementByKey(topLevelNodeKeys[topLevelNodeKeys.length - 1])];\n      const [firstNodeRect, lastNodeRect] = [firstNode != null ? firstNode.getBoundingClientRect() : undefined, lastNode != null ? lastNode.getBoundingClientRect() : undefined];\n      if (firstNodeRect && lastNodeRect) {\n        const firstNodeZoom = calculateZoomLevel(firstNode);\n        const lastNodeZoom = calculateZoomLevel(lastNode);\n        if (event.y / firstNodeZoom < firstNodeRect.top) {\n          blockElem = firstNode;\n        } else if (event.y / lastNodeZoom > lastNodeRect.bottom) {\n          blockElem = lastNode;\n        }\n        if (blockElem) {\n          return;\n        }\n      }\n    }\n    let index = getCurrentIndex(topLevelNodeKeys.length);\n    let direction = Indeterminate;\n    while (index >= 0 && index < topLevelNodeKeys.length) {\n      const key = topLevelNodeKeys[index];\n      const elem = editor.getElementByKey(key);\n      if (elem === null) {\n        break;\n      }\n      const zoom = calculateZoomLevel(elem);\n      const point = new Point(event.x / zoom, event.y / zoom);\n      const domRect = Rectangle.fromDOM(elem);\n      const {\n        marginTop,\n        marginBottom\n      } = getCollapsedMargins(elem);\n      const rect = domRect.generateNewRect({\n        bottom: domRect.bottom + marginBottom,\n        left: anchorElementRect.left,\n        right: anchorElementRect.right,\n        top: domRect.top - marginTop\n      });\n      const {\n        result,\n        reason: {\n          isOnTopSide,\n          isOnBottomSide\n        }\n      } = rect.contains(point);\n      if (result) {\n        blockElem = elem;\n        prevIndex = index;\n        break;\n      }\n      if (direction === Indeterminate) {\n        if (isOnTopSide) {\n          direction = Upward;\n        } else if (isOnBottomSide) {\n          direction = Downward;\n        } else {\n          // stop search block element\n          direction = Infinity;\n        }\n      }\n      index += direction;\n    }\n  });\n  return blockElem;\n}\nfunction setMenuPosition(targetElem, floatingElem, anchorElem) {\n  if (!targetElem) {\n    floatingElem.style.opacity = '0';\n    floatingElem.style.transform = 'translate(-10000px, -10000px)';\n    return;\n  }\n  const targetRect = targetElem.getBoundingClientRect();\n  const targetStyle = window.getComputedStyle(targetElem);\n  const floatingElemRect = floatingElem.getBoundingClientRect();\n  const anchorElementRect = anchorElem.getBoundingClientRect();\n  const top = targetRect.top + (parseInt(targetStyle.lineHeight, 10) - floatingElemRect.height) / 2 - anchorElementRect.top;\n  const left = SPACE;\n  floatingElem.style.opacity = '1';\n  floatingElem.style.transform = `translate(${left}px, ${top}px)`;\n}\nfunction setDragImage(dataTransfer, draggableBlockElem) {\n  const {\n    transform\n  } = draggableBlockElem.style;\n\n  // Remove dragImage borders\n  draggableBlockElem.style.transform = 'translateZ(0)';\n  dataTransfer.setDragImage(draggableBlockElem, 0, 0);\n  setTimeout(() => {\n    draggableBlockElem.style.transform = transform;\n  });\n}\nfunction setTargetLine(targetLineElem, targetBlockElem, mouseY, anchorElem) {\n  const {\n    top: targetBlockElemTop,\n    height: targetBlockElemHeight\n  } = targetBlockElem.getBoundingClientRect();\n  const {\n    top: anchorTop,\n    width: anchorWidth\n  } = anchorElem.getBoundingClientRect();\n  const {\n    marginTop,\n    marginBottom\n  } = getCollapsedMargins(targetBlockElem);\n  let lineTop = targetBlockElemTop;\n  if (mouseY >= targetBlockElemTop) {\n    lineTop += targetBlockElemHeight + marginBottom / 2;\n  } else {\n    lineTop -= marginTop / 2;\n  }\n  const top = lineTop - anchorTop - TARGET_LINE_HALF_HEIGHT;\n  const left = TEXT_BOX_HORIZONTAL_PADDING - SPACE;\n  targetLineElem.style.transform = `translate(${left}px, ${top}px)`;\n  targetLineElem.style.width = `${anchorWidth - (TEXT_BOX_HORIZONTAL_PADDING - SPACE) * 2}px`;\n  targetLineElem.style.opacity = '.4';\n}\nfunction hideTargetLine(targetLineElem) {\n  if (targetLineElem) {\n    targetLineElem.style.opacity = '0';\n    targetLineElem.style.transform = 'translate(-10000px, -10000px)';\n  }\n}\nfunction useDraggableBlockMenu(editor, anchorElem, menuRef, targetLineRef, isEditable, menuComponent, targetLineComponent, isOnMenu) {\n  const scrollerElem = anchorElem.parentElement;\n  const isDraggingBlockRef = useRef(false);\n  const [draggableBlockElem, setDraggableBlockElem] = useState(null);\n  useEffect(() => {\n    function onMouseMove(event) {\n      const target = event.target;\n      if (target != null && !isHTMLElement(target)) {\n        setDraggableBlockElem(null);\n        return;\n      }\n      if (target != null && isOnMenu(target)) {\n        return;\n      }\n      const _draggableBlockElem = getBlockElement(anchorElem, editor, event);\n      setDraggableBlockElem(_draggableBlockElem);\n    }\n    function onMouseLeave() {\n      setDraggableBlockElem(null);\n    }\n    if (scrollerElem != null) {\n      scrollerElem.addEventListener('mousemove', onMouseMove);\n      scrollerElem.addEventListener('mouseleave', onMouseLeave);\n    }\n    return () => {\n      if (scrollerElem != null) {\n        scrollerElem.removeEventListener('mousemove', onMouseMove);\n        scrollerElem.removeEventListener('mouseleave', onMouseLeave);\n      }\n    };\n  }, [scrollerElem, anchorElem, editor, isOnMenu]);\n  useEffect(() => {\n    if (menuRef.current) {\n      setMenuPosition(draggableBlockElem, menuRef.current, anchorElem);\n    }\n  }, [anchorElem, draggableBlockElem, menuRef]);\n  useEffect(() => {\n    function onDragover(event) {\n      if (!isDraggingBlockRef.current) {\n        return false;\n      }\n      const [isFileTransfer] = eventFiles(event);\n      if (isFileTransfer) {\n        return false;\n      }\n      const {\n        pageY,\n        target\n      } = event;\n      if (target != null && !isHTMLElement(target)) {\n        return false;\n      }\n      const targetBlockElem = getBlockElement(anchorElem, editor, event, true);\n      const targetLineElem = targetLineRef.current;\n      if (targetBlockElem === null || targetLineElem === null) {\n        return false;\n      }\n      setTargetLine(targetLineElem, targetBlockElem, pageY / calculateZoomLevel(target), anchorElem);\n      // Prevent default event to be able to trigger onDrop events\n      event.preventDefault();\n      return true;\n    }\n    function $onDrop(event) {\n      if (!isDraggingBlockRef.current) {\n        return false;\n      }\n      const [isFileTransfer] = eventFiles(event);\n      if (isFileTransfer) {\n        return false;\n      }\n      const {\n        target,\n        dataTransfer,\n        pageY\n      } = event;\n      const dragData = dataTransfer != null ? dataTransfer.getData(DRAG_DATA_FORMAT) : '';\n      const draggedNode = $getNodeByKey(dragData);\n      if (!draggedNode) {\n        return false;\n      }\n      if (target != null && !isHTMLElement(target)) {\n        return false;\n      }\n      const targetBlockElem = getBlockElement(anchorElem, editor, event, true);\n      if (!targetBlockElem) {\n        return false;\n      }\n      const targetNode = $getNearestNodeFromDOMNode(targetBlockElem);\n      if (!targetNode) {\n        return false;\n      }\n      if (targetNode === draggedNode) {\n        return true;\n      }\n      const targetBlockElemTop = targetBlockElem.getBoundingClientRect().top;\n      if (pageY / calculateZoomLevel(target) >= targetBlockElemTop) {\n        targetNode.insertAfter(draggedNode);\n      } else {\n        targetNode.insertBefore(draggedNode);\n      }\n      setDraggableBlockElem(null);\n      return true;\n    }\n    return mergeRegister(editor.registerCommand(DRAGOVER_COMMAND, event => {\n      return onDragover(event);\n    }, COMMAND_PRIORITY_LOW), editor.registerCommand(DROP_COMMAND, event => {\n      return $onDrop(event);\n    }, COMMAND_PRIORITY_HIGH));\n  }, [anchorElem, editor, targetLineRef]);\n  function onDragStart(event) {\n    const dataTransfer = event.dataTransfer;\n    if (!dataTransfer || !draggableBlockElem) {\n      return;\n    }\n    setDragImage(dataTransfer, draggableBlockElem);\n    let nodeKey = '';\n    editor.update(() => {\n      const node = $getNearestNodeFromDOMNode(draggableBlockElem);\n      if (node) {\n        nodeKey = node.getKey();\n      }\n    });\n    isDraggingBlockRef.current = true;\n    dataTransfer.setData(DRAG_DATA_FORMAT, nodeKey);\n  }\n  function onDragEnd() {\n    isDraggingBlockRef.current = false;\n    hideTargetLine(targetLineRef.current);\n  }\n  return /*#__PURE__*/createPortal(/*#__PURE__*/jsxs(Fragment, {\n    children: [/*#__PURE__*/jsx(\"div\", {\n      draggable: true,\n      onDragStart: onDragStart,\n      onDragEnd: onDragEnd,\n      children: isEditable && menuComponent\n    }), targetLineComponent]\n  }), anchorElem);\n}\nfunction DraggableBlockPlugin_EXPERIMENTAL({\n  anchorElem = document.body,\n  menuRef,\n  targetLineRef,\n  menuComponent,\n  targetLineComponent,\n  isOnMenu\n}) {\n  const [editor] = useLexicalComposerContext();\n  return useDraggableBlockMenu(editor, anchorElem, menuRef, targetLineRef, editor._editable, menuComponent, targetLineComponent, isOnMenu);\n}\n\nexport { DraggableBlockPlugin_EXPERIMENTAL };\n"],
  "mappings": "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",
  "names": []
}
