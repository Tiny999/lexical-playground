{
  "version": 3,
  "sources": ["../../@lexical/html/LexicalHtml.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],
  "mappings": "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",
  "names": []
}
