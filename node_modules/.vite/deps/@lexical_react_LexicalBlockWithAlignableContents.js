import {
  $isDecoratorBlockNode
} from "./chunk-2GWWAA23.js";
import {
  useLexicalNodeSelection
} from "./chunk-UJYKK5ES.js";
import {
  useLexicalComposerContext
} from "./chunk-5BMJGEYX.js";
import {
  require_jsx_runtime
} from "./chunk-WLVB5OIP.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  $getNearestBlockElementAncestorOrThrow,
  mergeRegister
} from "./chunk-VPCBVKHR.js";
import "./chunk-VD5PEWHI.js";
import {
  $getNodeByKey,
  $getSelection,
  $isDecoratorNode,
  $isNodeSelection,
  $isRangeSelection,
  CLICK_COMMAND,
  COMMAND_PRIORITY_LOW,
  FORMAT_ELEMENT_COMMAND,
  KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND
} from "./chunk-CVCL6TEU.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@lexical/react/LexicalBlockWithAlignableContents.dev.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function BlockWithAlignableContents({
  children,
  format,
  nodeKey,
  className
}) {
  const [editor] = useLexicalComposerContext();
  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection(nodeKey);
  const ref = (0, import_react.useRef)(null);
  const $onDelete = (0, import_react.useCallback)((event) => {
    const deleteSelection = $getSelection();
    if (isSelected && $isNodeSelection(deleteSelection)) {
      event.preventDefault();
      editor.update(() => {
        deleteSelection.getNodes().forEach((node) => {
          if ($isDecoratorNode(node)) {
            node.remove();
          }
        });
      });
    }
    return false;
  }, [editor, isSelected]);
  (0, import_react.useEffect)(() => {
    return mergeRegister(editor.registerCommand(FORMAT_ELEMENT_COMMAND, (formatType) => {
      if (isSelected) {
        const selection = $getSelection();
        if ($isNodeSelection(selection)) {
          const node = $getNodeByKey(nodeKey);
          if ($isDecoratorBlockNode(node)) {
            node.setFormat(formatType);
          }
        } else if ($isRangeSelection(selection)) {
          const nodes = selection.getNodes();
          for (const node of nodes) {
            if ($isDecoratorBlockNode(node)) {
              node.setFormat(formatType);
            } else {
              const element = $getNearestBlockElementAncestorOrThrow(node);
              element.setFormat(formatType);
            }
          }
        }
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(CLICK_COMMAND, (event) => {
      if (event.target === ref.current) {
        event.preventDefault();
        if (!event.shiftKey) {
          clearSelection();
        }
        setSelected(!isSelected);
        return true;
      }
      return false;
    }, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_DELETE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_BACKSPACE_COMMAND, $onDelete, COMMAND_PRIORITY_LOW));
  }, [clearSelection, editor, isSelected, nodeKey, $onDelete, setSelected]);
  return (0, import_jsx_runtime.jsx)("div", {
    className: [className.base, isSelected ? className.focus : null].filter(Boolean).join(" "),
    ref,
    style: {
      textAlign: format ? format : void 0
    },
    children
  });
}
export {
  BlockWithAlignableContents
};
//# sourceMappingURL=@lexical_react_LexicalBlockWithAlignableContents.js.map
