{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalCharacterLimitPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useEffect, useState, useMemo } from 'react';\nimport { OverflowNode, $isOverflowNode, $createOverflowNode } from '@lexical/overflow';\nimport { $rootTextContent } from '@lexical/text';\nimport { mergeRegister, $dfs } from '@lexical/utils';\nimport { DELETE_CHARACTER_COMMAND, $getSelection, $isRangeSelection, $isElementNode, COMMAND_PRIORITY_LOW, $isTextNode, $isLeafNode, $setSelection } from 'lexical';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useCharacterLimit(editor, maxCharacters, optional = Object.freeze({})) {\n  const {\n    strlen = input => input.length,\n    // UTF-16\n    remainingCharacters = () => {\n      return;\n    }\n  } = optional;\n  useEffect(() => {\n    if (!editor.hasNodes([OverflowNode])) {\n      {\n        throw Error(`useCharacterLimit: OverflowNode not registered on editor`);\n      }\n    }\n  }, [editor]);\n  useEffect(() => {\n    let text = editor.getEditorState().read($rootTextContent);\n    let lastComputedTextLength = 0;\n    return mergeRegister(editor.registerTextContentListener(currentText => {\n      text = currentText;\n    }), editor.registerUpdateListener(({\n      dirtyLeaves,\n      dirtyElements\n    }) => {\n      const isComposing = editor.isComposing();\n      const hasContentChanges = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (isComposing || !hasContentChanges) {\n        return;\n      }\n      const textLength = strlen(text);\n      const textLengthAboveThreshold = textLength > maxCharacters || lastComputedTextLength !== null && lastComputedTextLength > maxCharacters;\n      const diff = maxCharacters - textLength;\n      remainingCharacters(diff);\n      if (lastComputedTextLength === null || textLengthAboveThreshold) {\n        const offset = findOffset(text, maxCharacters, strlen);\n        editor.update(() => {\n          $wrapOverflowedNodes(offset);\n        }, {\n          tag: 'history-merge'\n        });\n      }\n      lastComputedTextLength = textLength;\n    }), editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const overflow = anchorNode.getParent();\n      const overflowParent = overflow ? overflow.getParent() : null;\n      const parentNext = overflowParent ? overflowParent.getNextSibling() : null;\n      selection.deleteCharacter(isBackward);\n      if (overflowParent && overflowParent.isEmpty()) {\n        overflowParent.remove();\n      } else if ($isElementNode(parentNext) && parentNext.isEmpty()) {\n        parentNext.remove();\n      }\n      return true;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, maxCharacters, remainingCharacters, strlen]);\n}\nfunction findOffset(text, maxCharacters, strlen) {\n  const Segmenter = Intl.Segmenter;\n  let offsetUtf16 = 0;\n  let offset = 0;\n  if (typeof Segmenter === 'function') {\n    const segmenter = new Segmenter();\n    const graphemes = segmenter.segment(text);\n    for (const {\n      segment: grapheme\n    } of graphemes) {\n      const nextOffset = offset + strlen(grapheme);\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n      offset = nextOffset;\n      offsetUtf16 += grapheme.length;\n    }\n  } else {\n    const codepoints = Array.from(text);\n    const codepointsLength = codepoints.length;\n    for (let i = 0; i < codepointsLength; i++) {\n      const codepoint = codepoints[i];\n      const nextOffset = offset + strlen(codepoint);\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n      offset = nextOffset;\n      offsetUtf16 += codepoint.length;\n    }\n  }\n  return offsetUtf16;\n}\nfunction $wrapOverflowedNodes(offset) {\n  const dfsNodes = $dfs();\n  const dfsNodesLength = dfsNodes.length;\n  let accumulatedLength = 0;\n  for (let i = 0; i < dfsNodesLength; i += 1) {\n    const {\n      node\n    } = dfsNodes[i];\n    if ($isOverflowNode(node)) {\n      const previousLength = accumulatedLength;\n      const nextLength = accumulatedLength + node.getTextContentSize();\n      if (nextLength <= offset) {\n        const parent = node.getParent();\n        const previousSibling = node.getPreviousSibling();\n        const nextSibling = node.getNextSibling();\n        $unwrapNode(node);\n        const selection = $getSelection();\n\n        // Restore selection when the overflow children are removed\n        if ($isRangeSelection(selection) && (!selection.anchor.getNode().isAttached() || !selection.focus.getNode().isAttached())) {\n          if ($isTextNode(previousSibling)) {\n            previousSibling.select();\n          } else if ($isTextNode(nextSibling)) {\n            nextSibling.select();\n          } else if (parent !== null) {\n            parent.select();\n          }\n        }\n      } else if (previousLength < offset) {\n        const descendant = node.getFirstDescendant();\n        const descendantLength = descendant !== null ? descendant.getTextContentSize() : 0;\n        const previousPlusDescendantLength = previousLength + descendantLength;\n        // For simple text we can redimension the overflow into a smaller and more accurate\n        // container\n        const firstDescendantIsSimpleText = $isTextNode(descendant) && descendant.isSimpleText();\n        const firstDescendantDoesNotOverflow = previousPlusDescendantLength <= offset;\n        if (firstDescendantIsSimpleText || firstDescendantDoesNotOverflow) {\n          $unwrapNode(node);\n        }\n      }\n    } else if ($isLeafNode(node)) {\n      const previousAccumulatedLength = accumulatedLength;\n      accumulatedLength += node.getTextContentSize();\n      if (accumulatedLength > offset && !$isOverflowNode(node.getParent())) {\n        const previousSelection = $getSelection();\n        let overflowNode;\n\n        // For simple text we can improve the limit accuracy by splitting the TextNode\n        // on the split point\n        if (previousAccumulatedLength < offset && $isTextNode(node) && node.isSimpleText()) {\n          const [, overflowedText] = node.splitText(offset - previousAccumulatedLength);\n          overflowNode = $wrapNode(overflowedText);\n        } else {\n          overflowNode = $wrapNode(node);\n        }\n        if (previousSelection !== null) {\n          $setSelection(previousSelection);\n        }\n        $mergePrevious(overflowNode);\n      }\n    }\n  }\n}\nfunction $wrapNode(node) {\n  const overflowNode = $createOverflowNode();\n  node.replace(overflowNode);\n  overflowNode.append(node);\n  return overflowNode;\n}\nfunction $unwrapNode(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    node.insertBefore(children[i]);\n  }\n  node.remove();\n  return childrenLength > 0 ? children[childrenLength - 1] : null;\n}\nfunction $mergePrevious(overflowNode) {\n  const previousNode = overflowNode.getPreviousSibling();\n  if (!$isOverflowNode(previousNode)) {\n    return;\n  }\n  const firstChild = overflowNode.getFirstChild();\n  const previousNodeChildren = previousNode.getChildren();\n  const previousNodeChildrenLength = previousNodeChildren.length;\n  if (firstChild === null) {\n    overflowNode.append(...previousNodeChildren);\n  } else {\n    for (let i = 0; i < previousNodeChildrenLength; i++) {\n      firstChild.insertBefore(previousNodeChildren[i]);\n    }\n  }\n  const selection = $getSelection();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const anchorNode = anchor.getNode();\n    const focus = selection.focus;\n    const focusNode = anchor.getNode();\n    if (anchorNode.is(previousNode)) {\n      anchor.set(overflowNode.getKey(), anchor.offset, 'element');\n    } else if (anchorNode.is(overflowNode)) {\n      anchor.set(overflowNode.getKey(), previousNodeChildrenLength + anchor.offset, 'element');\n    }\n    if (focusNode.is(previousNode)) {\n      focus.set(overflowNode.getKey(), focus.offset, 'element');\n    } else if (focusNode.is(overflowNode)) {\n      focus.set(overflowNode.getKey(), previousNodeChildrenLength + focus.offset, 'element');\n    }\n  }\n  previousNode.remove();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CHARACTER_LIMIT = 5;\nlet textEncoderInstance = null;\nfunction textEncoder() {\n  if (window.TextEncoder === undefined) {\n    return null;\n  }\n  if (textEncoderInstance === null) {\n    textEncoderInstance = new window.TextEncoder();\n  }\n  return textEncoderInstance;\n}\nfunction utf8Length(text) {\n  const currentTextEncoder = textEncoder();\n  if (currentTextEncoder === null) {\n    // http://stackoverflow.com/a/5515960/210370\n    const m = encodeURIComponent(text).match(/%[89ABab]/g);\n    return text.length + (m ? m.length : 0);\n  }\n  return currentTextEncoder.encode(text).length;\n}\nfunction DefaultRenderer({\n  remainingCharacters\n}) {\n  return /*#__PURE__*/jsx(\"span\", {\n    className: `characters-limit ${remainingCharacters < 0 ? 'characters-limit-exceeded' : ''}`,\n    children: remainingCharacters\n  });\n}\nfunction CharacterLimitPlugin({\n  charset = 'UTF-16',\n  maxLength = CHARACTER_LIMIT,\n  renderer = DefaultRenderer\n}) {\n  const [editor] = useLexicalComposerContext();\n  const [remainingCharacters, setRemainingCharacters] = useState(maxLength);\n  const characterLimitProps = useMemo(() => ({\n    remainingCharacters: setRemainingCharacters,\n    strlen: text => {\n      if (charset === 'UTF-8') {\n        return utf8Length(text);\n      } else if (charset === 'UTF-16') {\n        return text.length;\n      } else {\n        throw new Error('Unrecognized charset');\n      }\n    }\n  }), [charset]);\n  useCharacterLimit(editor, maxLength, characterLimitProps);\n  return renderer({\n    remainingCharacters\n  });\n}\n\nexport { CharacterLimitPlugin };\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,mBAA6C;AAK7C,yBAAoB;AAUpB,SAAS,kBAAkB,QAAQ,eAAe,WAAW,OAAO,OAAO,CAAC,CAAC,GAAG;AAC9E,QAAM;AAAA,IACJ,SAAS,WAAS,MAAM;AAAA;AAAA,IAExB,sBAAsB,MAAM;AAC1B;AAAA,IACF;AAAA,EACF,IAAI;AACJ,8BAAU,MAAM;AACd,QAAI,CAAC,OAAO,SAAS,CAAC,YAAY,CAAC,GAAG;AACpC;AACE,cAAM,MAAM,0DAA0D;AAAA,MACxE;AAAA,IACF;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AACX,8BAAU,MAAM;AACd,QAAI,OAAO,OAAO,eAAe,EAAE,KAAK,gBAAgB;AACxD,QAAI,yBAAyB;AAC7B,WAAO,cAAc,OAAO,4BAA4B,iBAAe;AACrE,aAAO;AAAA,IACT,CAAC,GAAG,OAAO,uBAAuB,CAAC;AAAA,MACjC;AAAA,MACA;AAAA,IACF,MAAM;AACJ,YAAM,cAAc,OAAO,YAAY;AACvC,YAAM,oBAAoB,YAAY,OAAO,KAAK,cAAc,OAAO;AACvE,UAAI,eAAe,CAAC,mBAAmB;AACrC;AAAA,MACF;AACA,YAAM,aAAa,OAAO,IAAI;AAC9B,YAAM,2BAA2B,aAAa,iBAAiB,2BAA2B,QAAQ,yBAAyB;AAC3H,YAAM,OAAO,gBAAgB;AAC7B,0BAAoB,IAAI;AACxB,UAAI,2BAA2B,QAAQ,0BAA0B;AAC/D,cAAM,SAAS,WAAW,MAAM,eAAe,MAAM;AACrD,eAAO,OAAO,MAAM;AAClB,+BAAqB,MAAM;AAAA,QAC7B,GAAG;AAAA,UACD,KAAK;AAAA,QACP,CAAC;AAAA,MACH;AACA,+BAAyB;AAAA,IAC3B,CAAC,GAAG,OAAO,gBAAgB,0BAA0B,gBAAc;AACjE,YAAM,YAAY,cAAc;AAChC,UAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,eAAO;AAAA,MACT;AACA,YAAM,aAAa,UAAU,OAAO,QAAQ;AAC5C,YAAM,WAAW,WAAW,UAAU;AACtC,YAAM,iBAAiB,WAAW,SAAS,UAAU,IAAI;AACzD,YAAM,aAAa,iBAAiB,eAAe,eAAe,IAAI;AACtE,gBAAU,gBAAgB,UAAU;AACpC,UAAI,kBAAkB,eAAe,QAAQ,GAAG;AAC9C,uBAAe,OAAO;AAAA,MACxB,WAAW,eAAe,UAAU,KAAK,WAAW,QAAQ,GAAG;AAC7D,mBAAW,OAAO;AAAA,MACpB;AACA,aAAO;AAAA,IACT,GAAG,oBAAoB,CAAC;AAAA,EAC1B,GAAG,CAAC,QAAQ,eAAe,qBAAqB,MAAM,CAAC;AACzD;AACA,SAAS,WAAW,MAAM,eAAe,QAAQ;AAC/C,QAAM,YAAY,KAAK;AACvB,MAAI,cAAc;AAClB,MAAI,SAAS;AACb,MAAI,OAAO,cAAc,YAAY;AACnC,UAAM,YAAY,IAAI,UAAU;AAChC,UAAM,YAAY,UAAU,QAAQ,IAAI;AACxC,eAAW;AAAA,MACT,SAAS;AAAA,IACX,KAAK,WAAW;AACd,YAAM,aAAa,SAAS,OAAO,QAAQ;AAC3C,UAAI,aAAa,eAAe;AAC9B;AAAA,MACF;AACA,eAAS;AACT,qBAAe,SAAS;AAAA,IAC1B;AAAA,EACF,OAAO;AACL,UAAM,aAAa,MAAM,KAAK,IAAI;AAClC,UAAM,mBAAmB,WAAW;AACpC,aAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK;AACzC,YAAM,YAAY,WAAW,CAAC;AAC9B,YAAM,aAAa,SAAS,OAAO,SAAS;AAC5C,UAAI,aAAa,eAAe;AAC9B;AAAA,MACF;AACA,eAAS;AACT,qBAAe,UAAU;AAAA,IAC3B;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,qBAAqB,QAAQ;AACpC,QAAM,WAAW,KAAK;AACtB,QAAM,iBAAiB,SAAS;AAChC,MAAI,oBAAoB;AACxB,WAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK,GAAG;AAC1C,UAAM;AAAA,MACJ;AAAA,IACF,IAAI,SAAS,CAAC;AACd,QAAI,gBAAgB,IAAI,GAAG;AACzB,YAAM,iBAAiB;AACvB,YAAM,aAAa,oBAAoB,KAAK,mBAAmB;AAC/D,UAAI,cAAc,QAAQ;AACxB,cAAM,SAAS,KAAK,UAAU;AAC9B,cAAM,kBAAkB,KAAK,mBAAmB;AAChD,cAAM,cAAc,KAAK,eAAe;AACxC,oBAAY,IAAI;AAChB,cAAM,YAAY,cAAc;AAGhC,YAAI,kBAAkB,SAAS,MAAM,CAAC,UAAU,OAAO,QAAQ,EAAE,WAAW,KAAK,CAAC,UAAU,MAAM,QAAQ,EAAE,WAAW,IAAI;AACzH,cAAI,YAAY,eAAe,GAAG;AAChC,4BAAgB,OAAO;AAAA,UACzB,WAAW,YAAY,WAAW,GAAG;AACnC,wBAAY,OAAO;AAAA,UACrB,WAAW,WAAW,MAAM;AAC1B,mBAAO,OAAO;AAAA,UAChB;AAAA,QACF;AAAA,MACF,WAAW,iBAAiB,QAAQ;AAClC,cAAM,aAAa,KAAK,mBAAmB;AAC3C,cAAM,mBAAmB,eAAe,OAAO,WAAW,mBAAmB,IAAI;AACjF,cAAM,+BAA+B,iBAAiB;AAGtD,cAAM,8BAA8B,YAAY,UAAU,KAAK,WAAW,aAAa;AACvF,cAAM,iCAAiC,gCAAgC;AACvE,YAAI,+BAA+B,gCAAgC;AACjE,sBAAY,IAAI;AAAA,QAClB;AAAA,MACF;AAAA,IACF,WAAW,YAAY,IAAI,GAAG;AAC5B,YAAM,4BAA4B;AAClC,2BAAqB,KAAK,mBAAmB;AAC7C,UAAI,oBAAoB,UAAU,CAAC,gBAAgB,KAAK,UAAU,CAAC,GAAG;AACpE,cAAM,oBAAoB,cAAc;AACxC,YAAI;AAIJ,YAAI,4BAA4B,UAAU,YAAY,IAAI,KAAK,KAAK,aAAa,GAAG;AAClF,gBAAM,CAAC,EAAE,cAAc,IAAI,KAAK,UAAU,SAAS,yBAAyB;AAC5E,yBAAe,UAAU,cAAc;AAAA,QACzC,OAAO;AACL,yBAAe,UAAU,IAAI;AAAA,QAC/B;AACA,YAAI,sBAAsB,MAAM;AAC9B,wBAAc,iBAAiB;AAAA,QACjC;AACA,uBAAe,YAAY;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACF;AACA,SAAS,UAAU,MAAM;AACvB,QAAM,eAAe,oBAAoB;AACzC,OAAK,QAAQ,YAAY;AACzB,eAAa,OAAO,IAAI;AACxB,SAAO;AACT;AACA,SAAS,YAAY,MAAM;AACzB,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,iBAAiB,SAAS;AAChC,WAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK;AACvC,SAAK,aAAa,SAAS,CAAC,CAAC;AAAA,EAC/B;AACA,OAAK,OAAO;AACZ,SAAO,iBAAiB,IAAI,SAAS,iBAAiB,CAAC,IAAI;AAC7D;AACA,SAAS,eAAe,cAAc;AACpC,QAAM,eAAe,aAAa,mBAAmB;AACrD,MAAI,CAAC,gBAAgB,YAAY,GAAG;AAClC;AAAA,EACF;AACA,QAAM,aAAa,aAAa,cAAc;AAC9C,QAAM,uBAAuB,aAAa,YAAY;AACtD,QAAM,6BAA6B,qBAAqB;AACxD,MAAI,eAAe,MAAM;AACvB,iBAAa,OAAO,GAAG,oBAAoB;AAAA,EAC7C,OAAO;AACL,aAAS,IAAI,GAAG,IAAI,4BAA4B,KAAK;AACnD,iBAAW,aAAa,qBAAqB,CAAC,CAAC;AAAA,IACjD;AAAA,EACF;AACA,QAAM,YAAY,cAAc;AAChC,MAAI,kBAAkB,SAAS,GAAG;AAChC,UAAM,SAAS,UAAU;AACzB,UAAM,aAAa,OAAO,QAAQ;AAClC,UAAM,QAAQ,UAAU;AACxB,UAAM,YAAY,OAAO,QAAQ;AACjC,QAAI,WAAW,GAAG,YAAY,GAAG;AAC/B,aAAO,IAAI,aAAa,OAAO,GAAG,OAAO,QAAQ,SAAS;AAAA,IAC5D,WAAW,WAAW,GAAG,YAAY,GAAG;AACtC,aAAO,IAAI,aAAa,OAAO,GAAG,6BAA6B,OAAO,QAAQ,SAAS;AAAA,IACzF;AACA,QAAI,UAAU,GAAG,YAAY,GAAG;AAC9B,YAAM,IAAI,aAAa,OAAO,GAAG,MAAM,QAAQ,SAAS;AAAA,IAC1D,WAAW,UAAU,GAAG,YAAY,GAAG;AACrC,YAAM,IAAI,aAAa,OAAO,GAAG,6BAA6B,MAAM,QAAQ,SAAS;AAAA,IACvF;AAAA,EACF;AACA,eAAa,OAAO;AACtB;AAUA,IAAM,kBAAkB;AACxB,IAAI,sBAAsB;AAC1B,SAAS,cAAc;AACrB,MAAI,OAAO,gBAAgB,QAAW;AACpC,WAAO;AAAA,EACT;AACA,MAAI,wBAAwB,MAAM;AAChC,0BAAsB,IAAI,OAAO,YAAY;AAAA,EAC/C;AACA,SAAO;AACT;AACA,SAAS,WAAW,MAAM;AACxB,QAAM,qBAAqB,YAAY;AACvC,MAAI,uBAAuB,MAAM;AAE/B,UAAM,IAAI,mBAAmB,IAAI,EAAE,MAAM,YAAY;AACrD,WAAO,KAAK,UAAU,IAAI,EAAE,SAAS;AAAA,EACvC;AACA,SAAO,mBAAmB,OAAO,IAAI,EAAE;AACzC;AACA,SAAS,gBAAgB;AAAA,EACvB;AACF,GAAG;AACD,aAAoB,wBAAI,QAAQ;AAAA,IAC9B,WAAW,oBAAoB,sBAAsB,IAAI,8BAA8B,EAAE;AAAA,IACzF,UAAU;AAAA,EACZ,CAAC;AACH;AACA,SAAS,qBAAqB;AAAA,EAC5B,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,WAAW;AACb,GAAG;AACD,QAAM,CAAC,MAAM,IAAI,0BAA0B;AAC3C,QAAM,CAAC,qBAAqB,sBAAsB,QAAI,uBAAS,SAAS;AACxE,QAAM,0BAAsB,sBAAQ,OAAO;AAAA,IACzC,qBAAqB;AAAA,IACrB,QAAQ,UAAQ;AACd,UAAI,YAAY,SAAS;AACvB,eAAO,WAAW,IAAI;AAAA,MACxB,WAAW,YAAY,UAAU;AAC/B,eAAO,KAAK;AAAA,MACd,OAAO;AACL,cAAM,IAAI,MAAM,sBAAsB;AAAA,MACxC;AAAA,IACF;AAAA,EACF,IAAI,CAAC,OAAO,CAAC;AACb,oBAAkB,QAAQ,WAAW,mBAAmB;AACxD,SAAO,SAAS;AAAA,IACd;AAAA,EACF,CAAC;AACH;",
  "names": []
}
