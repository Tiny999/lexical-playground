{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalAutoLinkPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { AutoLinkNode, $isAutoLinkNode, $isLinkNode, TOGGLE_LINK_COMMAND, $createAutoLinkNode } from '@lexical/link';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { mergeRegister } from '@lexical/utils';\nimport { TextNode, $getSelection, $isRangeSelection, COMMAND_PRIORITY_LOW, $isTextNode, $isElementNode, $isLineBreakNode, $createTextNode, $isNodeSelection } from 'lexical';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n          const textNodesToMatch = getTextNodesToMatch(textNode);\n          $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n      const selection = $getSelection();\n      if (payload !== null || !$isRangeSelection(selection)) {\n        return false;\n      }\n      const nodes = selection.extract();\n      nodes.forEach(node => {\n        const parent = node.getParent();\n        if ($isAutoLinkNode(parent)) {\n          // invert the value\n          parent.setIsUnlinked(!parent.getIsUnlinked());\n          parent.markDirty();\n          return true;\n        }\n      });\n      return false;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexport { AutoLinkPlugin, createLinkMatcherWithRegExp };\n"],
  "mappings": "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",
  "names": []
}
