import {
  CONNECTED_COMMAND,
  TOGGLE_CONNECT_COMMAND,
  createBinding,
  createUndoManager,
  initLocalState,
  setLocalStateFocus,
  syncCursorPositions,
  syncLexicalUpdateToYjs,
  syncYjsChangesToLexical
} from "./chunk-GPI4W7OI.js";
import {
  useCollaborationContext
} from "./chunk-3XFI6V35.js";
import {
  UndoManager
} from "./chunk-6X5JWGVV.js";
import {
  useLexicalComposerContext
} from "./chunk-5BMJGEYX.js";
import {
  require_jsx_runtime
} from "./chunk-WLVB5OIP.js";
import {
  require_react_dom
} from "./chunk-TYILIMWK.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  mergeRegister
} from "./chunk-VPCBVKHR.js";
import "./chunk-VD5PEWHI.js";
import {
  $createParagraphNode,
  $getRoot,
  $getSelection,
  BLUR_COMMAND,
  CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND,
  COMMAND_PRIORITY_EDITOR,
  FOCUS_COMMAND,
  REDO_COMMAND,
  UNDO_COMMAND
} from "./chunk-CVCL6TEU.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@lexical/react/LexicalCollaborationPlugin.dev.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function useYjsCollaboration(editor, id, provider, docMap, name, color, shouldBootstrap, binding, setDoc, cursorsContainerRef, initialEditorState, awarenessData) {
  const isReloadingDoc = (0, import_react.useRef)(false);
  const connect = (0, import_react.useCallback)(() => provider.connect(), [provider]);
  const disconnect = (0, import_react.useCallback)(() => {
    try {
      provider.disconnect();
    } catch (e) {
    }
  }, [provider]);
  (0, import_react.useEffect)(() => {
    const {
      root
    } = binding;
    const {
      awareness
    } = provider;
    const onStatus = ({
      status
    }) => {
      editor.dispatchCommand(CONNECTED_COMMAND, status === "connected");
    };
    const onSync = (isSynced) => {
      if (shouldBootstrap && isSynced && root.isEmpty() && root._xmlText._length === 0 && isReloadingDoc.current === false) {
        initializeEditor(editor, initialEditorState);
      }
      isReloadingDoc.current = false;
    };
    const onAwarenessUpdate = () => {
      syncCursorPositions(binding, provider);
    };
    const onYjsTreeChanges = (events, transaction) => {
      const origin = transaction.origin;
      if (origin !== binding) {
        const isFromUndoManger = origin instanceof UndoManager;
        syncYjsChangesToLexical(binding, provider, events, isFromUndoManger);
      }
    };
    initLocalState(provider, name, color, document.activeElement === editor.getRootElement(), awarenessData || {});
    const onProviderDocReload = (ydoc) => {
      clearEditorSkipCollab(editor, binding);
      setDoc(ydoc);
      docMap.set(id, ydoc);
      isReloadingDoc.current = true;
    };
    provider.on("reload", onProviderDocReload);
    provider.on("status", onStatus);
    provider.on("sync", onSync);
    awareness.on("update", onAwarenessUpdate);
    root.getSharedType().observeDeep(onYjsTreeChanges);
    const removeListener = editor.registerUpdateListener(({
      prevEditorState,
      editorState,
      dirtyLeaves,
      dirtyElements,
      normalizedNodes,
      tags
    }) => {
      if (tags.has("skip-collab") === false) {
        syncLexicalUpdateToYjs(binding, provider, prevEditorState, editorState, dirtyElements, dirtyLeaves, normalizedNodes, tags);
      }
    });
    const connectionPromise = connect();
    return () => {
      if (isReloadingDoc.current === false) {
        if (connectionPromise) {
          connectionPromise.then(disconnect);
        } else {
          disconnect();
        }
      }
      provider.off("sync", onSync);
      provider.off("status", onStatus);
      provider.off("reload", onProviderDocReload);
      awareness.off("update", onAwarenessUpdate);
      root.getSharedType().unobserveDeep(onYjsTreeChanges);
      docMap.delete(id);
      removeListener();
    };
  }, [binding, color, connect, disconnect, docMap, editor, id, initialEditorState, name, provider, shouldBootstrap, awarenessData, setDoc]);
  const cursorsContainer = (0, import_react.useMemo)(() => {
    const ref = (element) => {
      binding.cursorsContainer = element;
    };
    return (0, import_react_dom.createPortal)((0, import_jsx_runtime.jsx)("div", {
      ref
    }), cursorsContainerRef && cursorsContainerRef.current || document.body);
  }, [binding, cursorsContainerRef]);
  (0, import_react.useEffect)(() => {
    return editor.registerCommand(TOGGLE_CONNECT_COMMAND, (payload) => {
      const shouldConnect = payload;
      if (shouldConnect) {
        console.log("Collaboration connected!");
        connect();
      } else {
        console.log("Collaboration disconnected!");
        disconnect();
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR);
  }, [connect, disconnect, editor]);
  return cursorsContainer;
}
function useYjsFocusTracking(editor, provider, name, color, awarenessData) {
  (0, import_react.useEffect)(() => {
    return mergeRegister(editor.registerCommand(FOCUS_COMMAND, () => {
      setLocalStateFocus(provider, name, color, true, awarenessData || {});
      return false;
    }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(BLUR_COMMAND, () => {
      setLocalStateFocus(provider, name, color, false, awarenessData || {});
      return false;
    }, COMMAND_PRIORITY_EDITOR));
  }, [color, editor, name, provider, awarenessData]);
}
function useYjsHistory(editor, binding) {
  const undoManager = (0, import_react.useMemo)(() => createUndoManager(binding, binding.root.getSharedType()), [binding]);
  (0, import_react.useEffect)(() => {
    const undo = () => {
      undoManager.undo();
    };
    const redo = () => {
      undoManager.redo();
    };
    return mergeRegister(editor.registerCommand(UNDO_COMMAND, () => {
      undo();
      return true;
    }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REDO_COMMAND, () => {
      redo();
      return true;
    }, COMMAND_PRIORITY_EDITOR));
  });
  const clearHistory = (0, import_react.useCallback)(() => {
    undoManager.clear();
  }, [undoManager]);
  React.useEffect(() => {
    const updateUndoRedoStates = () => {
      editor.dispatchCommand(CAN_UNDO_COMMAND, undoManager.undoStack.length > 0);
      editor.dispatchCommand(CAN_REDO_COMMAND, undoManager.redoStack.length > 0);
    };
    undoManager.on("stack-item-added", updateUndoRedoStates);
    undoManager.on("stack-item-popped", updateUndoRedoStates);
    undoManager.on("stack-cleared", updateUndoRedoStates);
    return () => {
      undoManager.off("stack-item-added", updateUndoRedoStates);
      undoManager.off("stack-item-popped", updateUndoRedoStates);
      undoManager.off("stack-cleared", updateUndoRedoStates);
    };
  }, [editor, undoManager]);
  return clearHistory;
}
function initializeEditor(editor, initialEditorState) {
  editor.update(() => {
    const root = $getRoot();
    if (root.isEmpty()) {
      if (initialEditorState) {
        switch (typeof initialEditorState) {
          case "string": {
            const parsedEditorState = editor.parseEditorState(initialEditorState);
            editor.setEditorState(parsedEditorState, {
              tag: "history-merge"
            });
            break;
          }
          case "object": {
            editor.setEditorState(initialEditorState, {
              tag: "history-merge"
            });
            break;
          }
          case "function": {
            editor.update(() => {
              const root1 = $getRoot();
              if (root1.isEmpty()) {
                initialEditorState(editor);
              }
            }, {
              tag: "history-merge"
            });
            break;
          }
        }
      } else {
        const paragraph = $createParagraphNode();
        root.append(paragraph);
        const {
          activeElement
        } = document;
        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {
          paragraph.select();
        }
      }
    }
  }, {
    tag: "history-merge"
  });
}
function clearEditorSkipCollab(editor, binding) {
  editor.update(() => {
    const root = $getRoot();
    root.clear();
    root.select();
  }, {
    tag: "skip-collab"
  });
  if (binding.cursors == null) {
    return;
  }
  const cursors = binding.cursors;
  if (cursors == null) {
    return;
  }
  const cursorsContainer = binding.cursorsContainer;
  if (cursorsContainer == null) {
    return;
  }
  const cursorsArr = Array.from(cursors.values());
  for (let i = 0; i < cursorsArr.length; i++) {
    const cursor = cursorsArr[i];
    const selection = cursor.selection;
    if (selection && selection.selections != null) {
      const selections = selection.selections;
      for (let j = 0; j < selections.length; j++) {
        cursorsContainer.removeChild(selections[i]);
      }
    }
  }
}
function CollaborationPlugin({
  id,
  providerFactory,
  shouldBootstrap,
  username,
  cursorColor,
  cursorsContainerRef,
  initialEditorState,
  excludedProperties,
  awarenessData
}) {
  const isBindingInitialized = (0, import_react.useRef)(false);
  const isProviderInitialized = (0, import_react.useRef)(false);
  const collabContext = useCollaborationContext(username, cursorColor);
  const {
    yjsDocMap,
    name,
    color
  } = collabContext;
  const [editor] = useLexicalComposerContext();
  (0, import_react.useEffect)(() => {
    collabContext.isCollabActive = true;
    return () => {
      if (editor._parentEditor == null) {
        collabContext.isCollabActive = false;
      }
    };
  }, [collabContext, editor]);
  const [provider, setProvider] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    if (isProviderInitialized.current) {
      return;
    }
    isProviderInitialized.current = true;
    const newProvider = providerFactory(id, yjsDocMap);
    setProvider(newProvider);
    return () => {
      newProvider.disconnect();
    };
  }, [id, providerFactory, yjsDocMap]);
  const [doc, setDoc] = (0, import_react.useState)(yjsDocMap.get(id));
  const [binding, setBinding] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    if (!provider) {
      return;
    }
    if (isBindingInitialized.current) {
      return;
    }
    isBindingInitialized.current = true;
    const newBinding = createBinding(editor, provider, id, doc || yjsDocMap.get(id), yjsDocMap, excludedProperties);
    setBinding(newBinding);
    return () => {
      newBinding.root.destroy(newBinding);
    };
  }, [editor, provider, id, yjsDocMap, doc, excludedProperties]);
  if (!provider || !binding) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  return (0, import_jsx_runtime.jsx)(YjsCollaborationCursors, {
    awarenessData,
    binding,
    collabContext,
    color,
    cursorsContainerRef,
    editor,
    id,
    initialEditorState,
    name,
    provider,
    setDoc,
    shouldBootstrap,
    yjsDocMap
  });
}
function YjsCollaborationCursors({
  editor,
  id,
  provider,
  yjsDocMap,
  name,
  color,
  shouldBootstrap,
  cursorsContainerRef,
  initialEditorState,
  awarenessData,
  collabContext,
  binding,
  setDoc
}) {
  const cursors = useYjsCollaboration(editor, id, provider, yjsDocMap, name, color, shouldBootstrap, binding, setDoc, cursorsContainerRef, initialEditorState, awarenessData);
  collabContext.clientID = binding.clientID;
  useYjsHistory(editor, binding);
  useYjsFocusTracking(editor, provider, name, color, awarenessData);
  return cursors;
}
export {
  CollaborationPlugin
};
//# sourceMappingURL=@lexical_react_LexicalCollaborationPlugin.js.map
