{
  "version": 3,
  "sources": ["../../@lexical/list/LexicalList.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, ElementNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, INSERT_PARAGRAPH_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    removeList(editor);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const hasHandledInsertParagraph = $handleListInsertParagraph();\n    if (hasHandledInsertParagraph) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n  return removeListener;\n}\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, registerList, removeList };\n"],
  "mappings": "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",
  "names": []
}
