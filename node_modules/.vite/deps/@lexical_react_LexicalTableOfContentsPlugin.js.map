{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalTableOfContentsPlugin.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { HeadingNode, $isHeadingNode } from '@lexical/rich-text';\nimport { $getNextRightPreorderNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $getNodeByKey, TextNode } from 'lexical';\nimport { useState, useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction toEntry(heading) {\n  return [heading.getKey(), heading.getTextContent(), heading.getTag()];\n}\nfunction $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents) {\n  if (newHeading === null) {\n    return currentTableOfContents;\n  }\n  const newEntry = toEntry(newHeading);\n  let newTableOfContents = [];\n  if (prevHeading === null) {\n    // check if key already exists\n    if (currentTableOfContents.length > 0 && currentTableOfContents[0][0] === newHeading.__key) {\n      return currentTableOfContents;\n    }\n    newTableOfContents = [newEntry, ...currentTableOfContents];\n  } else {\n    for (let i = 0; i < currentTableOfContents.length; i++) {\n      const key = currentTableOfContents[i][0];\n      newTableOfContents.push(currentTableOfContents[i]);\n      if (key === prevHeading.getKey() && key !== newHeading.getKey()) {\n        // check if key already exists\n        if (i + 1 < currentTableOfContents.length && currentTableOfContents[i + 1][0] === newHeading.__key) {\n          return currentTableOfContents;\n        }\n        newTableOfContents.push(newEntry);\n      }\n    }\n  }\n  return newTableOfContents;\n}\nfunction $deleteHeadingFromTableOfContents(key, currentTableOfContents) {\n  const newTableOfContents = [];\n  for (const heading of currentTableOfContents) {\n    if (heading[0] !== key) {\n      newTableOfContents.push(heading);\n    }\n  }\n  return newTableOfContents;\n}\nfunction $updateHeadingInTableOfContents(heading, currentTableOfContents) {\n  const newTableOfContents = [];\n  for (const oldHeading of currentTableOfContents) {\n    if (oldHeading[0] === heading.getKey()) {\n      newTableOfContents.push(toEntry(heading));\n    } else {\n      newTableOfContents.push(oldHeading);\n    }\n  }\n  return newTableOfContents;\n}\n\n/**\n * Returns the updated table of contents, placing the given `heading` before the given `prevHeading`. If `prevHeading`\n * is undefined, `heading` is placed at the start of table of contents\n */\nfunction $updateHeadingPosition(prevHeading, heading, currentTableOfContents) {\n  const newTableOfContents = [];\n  const newEntry = toEntry(heading);\n  if (!prevHeading) {\n    newTableOfContents.push(newEntry);\n  }\n  for (const oldHeading of currentTableOfContents) {\n    if (oldHeading[0] === heading.getKey()) {\n      continue;\n    }\n    newTableOfContents.push(oldHeading);\n    if (prevHeading && oldHeading[0] === prevHeading.getKey()) {\n      newTableOfContents.push(newEntry);\n    }\n  }\n  return newTableOfContents;\n}\nfunction $getPreviousHeading(node) {\n  let prevHeading = $getNextRightPreorderNode(node);\n  while (prevHeading !== null && !$isHeadingNode(prevHeading)) {\n    prevHeading = $getNextRightPreorderNode(prevHeading);\n  }\n  return prevHeading;\n}\nfunction TableOfContentsPlugin({\n  children\n}) {\n  const [tableOfContents, setTableOfContents] = useState([]);\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    // Set table of contents initial state\n    let currentTableOfContents = [];\n    editor.getEditorState().read(() => {\n      const updateCurrentTableOfContents = node => {\n        for (const child of node.getChildren()) {\n          if ($isHeadingNode(child)) {\n            currentTableOfContents.push([child.getKey(), child.getTextContent(), child.getTag()]);\n          } else if ($isElementNode(child)) {\n            updateCurrentTableOfContents(child);\n          }\n        }\n      };\n      updateCurrentTableOfContents($getRoot());\n      setTableOfContents(currentTableOfContents);\n    });\n    const removeRootUpdateListener = editor.registerUpdateListener(({\n      editorState,\n      dirtyElements\n    }) => {\n      editorState.read(() => {\n        const updateChildHeadings = node => {\n          for (const child of node.getChildren()) {\n            if ($isHeadingNode(child)) {\n              const prevHeading = $getPreviousHeading(child);\n              currentTableOfContents = $updateHeadingPosition(prevHeading, child, currentTableOfContents);\n              setTableOfContents(currentTableOfContents);\n            } else if ($isElementNode(child)) {\n              updateChildHeadings(child);\n            }\n          }\n        };\n\n        // If a node is changes, all child heading positions need to be updated\n        $getRoot().getChildren().forEach(node => {\n          if ($isElementNode(node) && dirtyElements.get(node.__key)) {\n            updateChildHeadings(node);\n          }\n        });\n      });\n    });\n\n    // Listen to updates to heading mutations and update state\n    const removeHeaderMutationListener = editor.registerMutationListener(HeadingNode, mutatedNodes => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'created') {\n            const newHeading = $getNodeByKey(nodeKey);\n            if (newHeading !== null) {\n              const prevHeading = $getPreviousHeading(newHeading);\n              currentTableOfContents = $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents);\n            }\n          } else if (mutation === 'destroyed') {\n            currentTableOfContents = $deleteHeadingFromTableOfContents(nodeKey, currentTableOfContents);\n          } else if (mutation === 'updated') {\n            const newHeading = $getNodeByKey(nodeKey);\n            if (newHeading !== null) {\n              const prevHeading = $getPreviousHeading(newHeading);\n              currentTableOfContents = $updateHeadingPosition(prevHeading, newHeading, currentTableOfContents);\n            }\n          }\n        }\n        setTableOfContents(currentTableOfContents);\n      });\n    },\n    // Initialization is handled separately\n    {\n      skipInitialization: true\n    });\n\n    // Listen to text node mutation updates\n    const removeTextNodeMutationListener = editor.registerMutationListener(TextNode, mutatedNodes => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'updated') {\n            const currNode = $getNodeByKey(nodeKey);\n            if (currNode !== null) {\n              const parentNode = currNode.getParentOrThrow();\n              if ($isHeadingNode(parentNode)) {\n                currentTableOfContents = $updateHeadingInTableOfContents(parentNode, currentTableOfContents);\n                setTableOfContents(currentTableOfContents);\n              }\n            }\n          }\n        }\n      });\n    },\n    // Initialization is handled separately\n    {\n      skipInitialization: true\n    });\n    return () => {\n      removeHeaderMutationListener();\n      removeTextNodeMutationListener();\n      removeRootUpdateListener();\n    };\n  }, [editor]);\n  return children(tableOfContents, editor);\n}\n\nexport { TableOfContentsPlugin };\n"],
  "mappings": "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",
  "names": []
}
