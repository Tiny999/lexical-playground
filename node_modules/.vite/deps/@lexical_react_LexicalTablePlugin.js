import {
  $computeTableMap,
  $computeTableMapSkipCellCheck,
  $createTableCellNode,
  $createTableNodeWithDimensions,
  $getNodeTriplet,
  $isTableCellNode,
  $isTableNode,
  $isTableRowNode,
  INSERT_TABLE_COMMAND,
  TableCellNode,
  TableNode,
  TableRowNode,
  applyTableHandlers
} from "./chunk-UGUJAH4X.js";
import "./chunk-UV775WKF.js";
import {
  useLexicalComposerContext
} from "./chunk-5BMJGEYX.js";
import "./chunk-O6OHZHAK.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  $insertFirst,
  $insertNodeToNearestRoot,
  mergeRegister
} from "./chunk-VPCBVKHR.js";
import "./chunk-VD5PEWHI.js";
import {
  $createParagraphNode,
  $getNodeByKey,
  $isTextNode,
  COMMAND_PRIORITY_EDITOR
} from "./chunk-CVCL6TEU.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@lexical/react/LexicalTablePlugin.dev.mjs
var import_react = __toESM(require_react(), 1);
function TablePlugin({
  hasCellMerge = true,
  hasCellBackgroundColor = true,
  hasTabHandler = true
}) {
  const [editor] = useLexicalComposerContext();
  (0, import_react.useEffect)(() => {
    if (!editor.hasNodes([TableNode, TableCellNode, TableRowNode])) {
      {
        throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);
      }
    }
    return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, ({
      columns,
      rows,
      includeHeaders
    }) => {
      const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);
      $insertNodeToNearestRoot(tableNode);
      const firstDescendant = tableNode.getFirstDescendant();
      if ($isTextNode(firstDescendant)) {
        firstDescendant.select();
      }
      return true;
    }, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, (node) => {
      const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);
      const maxRowLength = gridMap.reduce((curLength, row) => {
        return Math.max(curLength, row.length);
      }, 0);
      const rowNodes = node.getChildren();
      for (let i = 0; i < gridMap.length; ++i) {
        const rowNode = rowNodes[i];
        if (!rowNode) {
          continue;
        }
        const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);
        if (rowLength === maxRowLength) {
          continue;
        }
        for (let j = rowLength; j < maxRowLength; ++j) {
          const newCell = $createTableCellNode(0);
          newCell.append($createParagraphNode());
          rowNode.append(newCell);
        }
      }
    }));
  }, [editor]);
  (0, import_react.useEffect)(() => {
    const tableSelections = /* @__PURE__ */ new Map();
    const initializeTableNode = (tableNode, nodeKey, dom) => {
      const tableElement = dom;
      const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);
      tableSelections.set(nodeKey, [tableSelection, tableElement]);
    };
    const unregisterMutationListener = editor.registerMutationListener(TableNode, (nodeMutations) => {
      for (const [nodeKey, mutation] of nodeMutations) {
        if (mutation === "created" || mutation === "updated") {
          const tableSelection = tableSelections.get(nodeKey);
          const dom = editor.getElementByKey(nodeKey);
          if (!(tableSelection && dom === tableSelection[1])) {
            if (tableSelection) {
              tableSelection[0].removeListeners();
              tableSelections.delete(nodeKey);
            }
            if (dom !== null) {
              editor.getEditorState().read(() => {
                const tableNode = $getNodeByKey(nodeKey);
                if ($isTableNode(tableNode)) {
                  initializeTableNode(tableNode, nodeKey, dom);
                }
              });
            }
          }
        } else if (mutation === "destroyed") {
          const tableSelection = tableSelections.get(nodeKey);
          if (tableSelection !== void 0) {
            tableSelection[0].removeListeners();
            tableSelections.delete(nodeKey);
          }
        }
      }
    }, {
      skipInitialization: false
    });
    return () => {
      unregisterMutationListener();
      for (const [, [tableSelection]] of tableSelections) {
        tableSelection.removeListeners();
      }
    };
  }, [editor, hasTabHandler]);
  (0, import_react.useEffect)(() => {
    if (hasCellMerge) {
      return;
    }
    return editor.registerNodeTransform(TableCellNode, (node) => {
      if (node.getColSpan() > 1 || node.getRowSpan() > 1) {
        const [, , gridNode] = $getNodeTriplet(node);
        const [gridMap] = $computeTableMap(gridNode, node, node);
        const rowsCount = gridMap.length;
        const columnsCount = gridMap[0].length;
        let row = gridNode.getFirstChild();
        if (!$isTableRowNode(row)) {
          throw Error(`Expected TableNode first child to be a RowNode`);
        }
        const unmerged = [];
        for (let i = 0; i < rowsCount; i++) {
          if (i !== 0) {
            row = row.getNextSibling();
            if (!$isTableRowNode(row)) {
              throw Error(`Expected TableNode first child to be a RowNode`);
            }
          }
          let lastRowCell = null;
          for (let j = 0; j < columnsCount; j++) {
            const cellMap = gridMap[i][j];
            const cell = cellMap.cell;
            if (cellMap.startRow === i && cellMap.startColumn === j) {
              lastRowCell = cell;
              unmerged.push(cell);
            } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {
              if (!$isTableCellNode(cell)) {
                throw Error(`Expected TableNode cell to be a TableCellNode`);
              }
              const newCell = $createTableCellNode(cell.__headerState);
              if (lastRowCell !== null) {
                lastRowCell.insertAfter(newCell);
              } else {
                $insertFirst(row, newCell);
              }
            }
          }
        }
        for (const cell of unmerged) {
          cell.setColSpan(1);
          cell.setRowSpan(1);
        }
      }
    });
  }, [editor, hasCellMerge]);
  (0, import_react.useEffect)(() => {
    if (hasCellBackgroundColor) {
      return;
    }
    return editor.registerNodeTransform(TableCellNode, (node) => {
      if (node.getBackgroundColor() !== null) {
        node.setBackgroundColor(null);
      }
    });
  }, [editor, hasCellBackgroundColor, hasCellMerge]);
  return null;
}
export {
  TablePlugin
};
//# sourceMappingURL=@lexical_react_LexicalTablePlugin.js.map
