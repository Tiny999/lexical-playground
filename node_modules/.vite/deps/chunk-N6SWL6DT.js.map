{
  "version": 3,
  "sources": ["../../@lexical/hashtag/LexicalHashtag.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement } from '@lexical/utils';\nimport { TextNode, $applyNodeReplacement } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/** @noInheritDoc */\nclass HashtagNode extends TextNode {\n  static getType() {\n    return 'hashtag';\n  }\n  static clone(node) {\n    return new HashtagNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(text, key);\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    addClassNamesToElement(element, config.theme.hashtag);\n    return element;\n  }\n  static importJSON(serializedNode) {\n    const node = $createHashtagNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'hashtag'\n    };\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  isTextEntity() {\n    return true;\n  }\n}\n\n/**\n * Generates a HashtagNode, which is a string following the format of a # followed by some text, eg. #lexical.\n * @param text - The text used inside the HashtagNode.\n * @returns - The HashtagNode with the embedded text.\n */\nfunction $createHashtagNode(text = '') {\n  return $applyNodeReplacement(new HashtagNode(text));\n}\n\n/**\n * Determines if node is a HashtagNode.\n * @param node - The node to be checked.\n * @returns true if node is a HashtagNode, false otherwise.\n */\nfunction $isHashtagNode(node) {\n  return node instanceof HashtagNode;\n}\n\nexport { $createHashtagNode, $isHashtagNode, HashtagNode };\n"],
  "mappings": ";;;;;;;;;AAqBA,IAAM,cAAN,MAAM,qBAAoB,SAAS;AAAA,EACjC,OAAO,UAAU;AACf,WAAO;AAAA,EACT;AAAA,EACA,OAAO,MAAM,MAAM;AACjB,WAAO,IAAI,aAAY,KAAK,QAAQ,KAAK,KAAK;AAAA,EAChD;AAAA,EACA,YAAY,MAAM,KAAK;AACrB,UAAM,MAAM,GAAG;AAAA,EACjB;AAAA,EACA,UAAU,QAAQ;AAChB,UAAM,UAAU,MAAM,UAAU,MAAM;AACtC,2BAAuB,SAAS,OAAO,MAAM,OAAO;AACpD,WAAO;AAAA,EACT;AAAA,EACA,OAAO,WAAW,gBAAgB;AAChC,UAAM,OAAO,mBAAmB,eAAe,IAAI;AACnD,SAAK,UAAU,eAAe,MAAM;AACpC,SAAK,UAAU,eAAe,MAAM;AACpC,SAAK,QAAQ,eAAe,IAAI;AAChC,SAAK,SAAS,eAAe,KAAK;AAClC,WAAO;AAAA,EACT;AAAA,EACA,aAAa;AACX,WAAO;AAAA,MACL,GAAG,MAAM,WAAW;AAAA,MACpB,MAAM;AAAA,IACR;AAAA,EACF;AAAA,EACA,sBAAsB;AACpB,WAAO;AAAA,EACT;AAAA,EACA,eAAe;AACb,WAAO;AAAA,EACT;AACF;AAOA,SAAS,mBAAmB,OAAO,IAAI;AACrC,SAAO,sBAAsB,IAAI,YAAY,IAAI,CAAC;AACpD;AAOA,SAAS,eAAe,MAAM;AAC5B,SAAO,gBAAgB;AACzB;",
  "names": []
}
