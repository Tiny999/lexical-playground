{
  "version": 3,
  "sources": ["../../@lexical/text/LexicalText.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n"],
  "mappings": ";;;;;;;;;;;AAsBA,SAAS,mBAAmB;AAC1B,QAAM,OAAO,SAAS;AACtB,SAAO,KAAK,eAAe;AAC7B;AAgBA,SAAS,wBAAwB,mBAAmB,OAAO,MAAM;AAC/D,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,iBAAiB;AAC5B,MAAI,MAAM;AACR,WAAO,KAAK,KAAK;AAAA,EACnB;AACA,SAAO,SAAS;AAClB;AAQA,SAAS,6BAA6B,mBAAmB,MAAM;AAC7D,SAAO,MAAM,wBAAwB,mBAAmB,IAAI;AAC9D;AAgBA,SAAS,oBAAoB,aAAa;AACxC,MAAI,CAAC,wBAAwB,aAAa,KAAK,GAAG;AAChD,WAAO;AAAA,EACT;AACA,QAAM,OAAO,SAAS;AACtB,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,iBAAiB,SAAS;AAChC,MAAI,iBAAiB,GAAG;AACtB,WAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK;AACvC,UAAM,WAAW,SAAS,CAAC;AAC3B,QAAI,iBAAiB,QAAQ,GAAG;AAC9B,aAAO;AAAA,IACT;AACA,QAAI,eAAe,QAAQ,GAAG;AAC5B,UAAI,CAAC,iBAAiB,QAAQ,GAAG;AAC/B,eAAO;AAAA,MACT;AACA,UAAI,SAAS,aAAa,GAAG;AAC3B,eAAO;AAAA,MACT;AACA,YAAM,mBAAmB,SAAS,YAAY;AAC9C,YAAM,yBAAyB,iBAAiB;AAChD,eAAS,IAAI,GAAG,IAAI,wBAAwB,KAAK;AAC/C,cAAM,QAAQ,iBAAiB,CAAC;AAChC,YAAI,CAAC,YAAY,KAAK,GAAG;AACvB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,yBAAyB,mBAAmB;AACnD,SAAO,MAAM,oBAAoB,iBAAiB;AACpD;AAiBA,SAAS,oCAAoC,MAAM,kBAAkB;AACnE,MAAI,OAAO,KAAK,cAAc;AAC9B,MAAI,oBAAoB;AACxB,WAAU,QAAO,SAAS,MAAM;AAC9B,QAAI,eAAe,IAAI,GAAG;AACxB,YAAM,QAAQ,KAAK,cAAc;AACjC,UAAI,UAAU,MAAM;AAClB,eAAO;AACP;AAAA,MACF;AAAA,IACF,WAAW,YAAY,IAAI,GAAG;AAC5B,YAAM,aAAa,KAAK,mBAAmB;AAC3C,UAAI,oBAAoB,aAAa,kBAAkB;AACrD,eAAO;AAAA,UACL;AAAA,UACA,QAAQ,mBAAmB;AAAA,QAC7B;AAAA,MACF;AACA,2BAAqB;AAAA,IACvB;AACA,UAAM,UAAU,KAAK,eAAe;AACpC,QAAI,YAAY,MAAM;AACpB,aAAO;AACP;AAAA,IACF;AACA,QAAI,SAAS,KAAK,UAAU;AAC5B,WAAO,WAAW,MAAM;AACtB,YAAM,gBAAgB,OAAO,eAAe;AAC5C,UAAI,kBAAkB,MAAM;AAC1B,eAAO;AACP,iBAAS;AAAA,MACX;AACA,eAAS,OAAO,UAAU;AAAA,IAC5B;AACA;AAAA,EACF;AACA,SAAO;AACT;AA6BA,SAAS,0BAA0B,QAAQ,UAAU,YAAY,YAAY;AAC3E,QAAM,eAAe,UAAQ;AAC3B,WAAO,gBAAgB;AAAA,EACzB;AACA,QAAM,yBAAyB,UAAQ;AACrC,UAAM,WAAW,gBAAgB,KAAK,eAAe,CAAC;AACtD,aAAS,UAAU,KAAK,UAAU,CAAC;AACnC,SAAK,QAAQ,QAAQ;AAAA,EACvB;AACA,QAAM,UAAU,UAAQ;AACtB,WAAO,KAAK,UAAU,EAAE;AAAA,EAC1B;AACA,QAAM,qBAAqB,UAAQ;AACjC,QAAI,CAAC,KAAK,aAAa,GAAG;AACxB;AAAA,IACF;AACA,QAAI,cAAc,KAAK,mBAAmB;AAC1C,QAAI,OAAO,KAAK,eAAe;AAC/B,QAAI,cAAc;AAClB,QAAI;AACJ,QAAI,YAAY,WAAW,GAAG;AAC5B,YAAM,eAAe,YAAY,eAAe;AAChD,YAAM,eAAe,eAAe;AACpC,YAAM,YAAY,SAAS,YAAY;AACvC,UAAI,aAAa,WAAW,GAAG;AAC7B,YAAI,cAAc,QAAQ,QAAQ,WAAW,MAAM,GAAG;AACpD,iCAAuB,WAAW;AAClC;AAAA,QACF,OAAO;AACL,gBAAM,OAAO,UAAU,MAAM,aAAa;AAC1C,cAAI,OAAO,GAAG;AACZ,kBAAM,aAAa,KAAK,MAAM,GAAG,IAAI;AACrC,kBAAM,iBAAiB,eAAe;AACtC,wBAAY,OAAO;AACnB,wBAAY,eAAe,cAAc;AACzC,gBAAI,SAAS,KAAK,QAAQ;AACxB,mBAAK,OAAO;AAAA,YACd,OAAO;AACL,oBAAM,gBAAgB,KAAK,MAAM,IAAI;AACrC,mBAAK,eAAe,aAAa;AAAA,YACnC;AACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,cAAc,QAAQ,UAAU,QAAQ,aAAa,QAAQ;AACtE;AAAA,MACF;AAAA,IACF;AACA,QAAI,wBAAwB;AAE5B,WAAO,MAAM;AACX,cAAQ,SAAS,IAAI;AACrB,UAAI,WAAW,UAAU,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AACzD,aAAO;AACP,UAAI,aAAa,IAAI;AACnB,cAAM,cAAc,YAAY,eAAe;AAC/C,YAAI,YAAY,WAAW,GAAG;AAC5B,qBAAW,YAAY,eAAe,IAAI,YAAY,eAAe;AACrE,gBAAM,YAAY,SAAS,QAAQ;AACnC,cAAI,cAAc,MAAM;AACtB,gBAAI,aAAa,WAAW,GAAG;AAC7B,qCAAuB,WAAW;AAAA,YACpC,OAAO;AACL,0BAAY,UAAU;AAAA,YACxB;AACA;AAAA,UACF,WAAW,UAAU,UAAU,GAAG;AAChC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,UAAU,MAAM;AAClB;AAAA,MACF;AACA,UAAI,MAAM,UAAU,KAAK,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC/E,iCAAyB,MAAM;AAC/B;AAAA,MACF;AACA,UAAI;AACJ,UAAI,MAAM,UAAU,GAAG;AACrB,SAAC,eAAe,WAAW,IAAI,YAAY,UAAU,MAAM,GAAG;AAAA,MAChE,OAAO;AACL,SAAC,EAAE,eAAe,WAAW,IAAI,YAAY,UAAU,MAAM,QAAQ,uBAAuB,MAAM,MAAM,qBAAqB;AAAA,MAC/H;AACA,UAAI,EAAE,kBAAkB,SAAY;AAClC,cAAM,MAAM,GAAG,eAAe,uFAAuF;AAAA,MACvH;AACA,YAAM,kBAAkB,WAAW,aAAa;AAChD,sBAAgB,UAAU,cAAc,UAAU,CAAC;AACnD,oBAAc,QAAQ,eAAe;AACrC,UAAI,eAAe,MAAM;AACvB;AAAA,MACF;AACA,8BAAwB;AACxB,oBAAc;AAAA,IAChB;AAAA,EACF;AACA,QAAM,wBAAwB,UAAQ;AACpC,UAAM,OAAO,KAAK,eAAe;AACjC,UAAM,QAAQ,SAAS,IAAI;AAC3B,QAAI,UAAU,QAAQ,MAAM,UAAU,GAAG;AACvC,6BAAuB,IAAI;AAC3B;AAAA,IACF;AACA,QAAI,KAAK,SAAS,MAAM,KAAK;AAE3B,WAAK,UAAU,MAAM,GAAG;AACxB;AAAA,IACF;AACA,UAAM,cAAc,KAAK,mBAAmB;AAC5C,QAAI,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC1D,6BAAuB,WAAW;AAClC,6BAAuB,IAAI;AAAA,IAC7B;AACA,UAAM,cAAc,KAAK,eAAe;AACxC,QAAI,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC1D,6BAAuB,WAAW;AAGlC,UAAI,aAAa,IAAI,GAAG;AACtB,+BAAuB,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACA,QAAM,2BAA2B,OAAO,sBAAsB,UAAU,kBAAkB;AAC1F,QAAM,6BAA6B,OAAO,sBAAsB,YAAY,qBAAqB;AACjG,SAAO,CAAC,0BAA0B,0BAA0B;AAC9D;",
  "names": []
}
