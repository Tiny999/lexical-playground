{
  "version": 3,
  "sources": ["../../@lexical/offset/LexicalOffset.dev.mjs", "../../@lexical/yjs/LexicalYjs.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNodeByKey, $isTextNode, $createRangeSelection, $isElementNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass OffsetView {\n  constructor(offsetMap, firstNode, blockOffsetSize = 1) {\n    this._offsetMap = offsetMap;\n    this._firstNode = firstNode;\n    this._blockOffsetSize = blockOffsetSize;\n  }\n  createSelectionFromOffsets(originalStart, originalEnd, diffOffsetView) {\n    const firstNode = this._firstNode;\n    if (firstNode === null) {\n      return null;\n    }\n    let start = originalStart;\n    let end = originalEnd;\n    let startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n    let endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n    if (diffOffsetView !== undefined) {\n      start = $getAdjustedOffsetFromDiff(start, startOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n      end = $getAdjustedOffsetFromDiff(end, endOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n    }\n    if (startOffsetNode === null || endOffsetNode === null) {\n      return null;\n    }\n    let startKey = startOffsetNode.key;\n    let endKey = endOffsetNode.key;\n    const startNode = $getNodeByKey(startKey);\n    const endNode = $getNodeByKey(endKey);\n    if (startNode === null || endNode === null) {\n      return null;\n    }\n    let startOffset = 0;\n    let endOffset = 0;\n    let startType = 'element';\n    let endType = 'element';\n    if (startOffsetNode.type === 'text') {\n      startOffset = start - startOffsetNode.start;\n      startType = 'text';\n      // If we are at the edge of a text node and we\n      // don't have a collapsed selection, then let's\n      // try and correct the offset node.\n      const sibling = startNode.getNextSibling();\n      if (start !== end && startOffset === startNode.getTextContentSize() && $isTextNode(sibling)) {\n        startOffset = 0;\n        startKey = sibling.__key;\n      }\n    } else if (startOffsetNode.type === 'inline') {\n      startKey = startNode.getParentOrThrow().getKey();\n      startOffset = end > startOffsetNode.start ? startOffsetNode.end : startOffsetNode.start;\n    }\n    if (endOffsetNode.type === 'text') {\n      endOffset = end - endOffsetNode.start;\n      endType = 'text';\n    } else if (endOffsetNode.type === 'inline') {\n      endKey = endNode.getParentOrThrow().getKey();\n      endOffset = end > endOffsetNode.start ? endOffsetNode.end : endOffsetNode.start;\n    }\n    const selection = $createRangeSelection();\n    if (selection === null) {\n      return null;\n    }\n    selection.anchor.set(startKey, startOffset, startType);\n    selection.focus.set(endKey, endOffset, endType);\n    return selection;\n  }\n  getOffsetsFromSelection(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const offsetMap = this._offsetMap;\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    let start = -1;\n    let end = -1;\n    if (anchor.type === 'text') {\n      const offsetNode = offsetMap.get(anchor.key);\n      if (offsetNode !== undefined) {\n        start = offsetNode.start + anchorOffset;\n      }\n    } else {\n      const node = anchor.getNode().getDescendantByIndex(anchorOffset);\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== anchorOffset;\n          start = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n    if (focus.type === 'text') {\n      const offsetNode = offsetMap.get(focus.key);\n      if (offsetNode !== undefined) {\n        end = offsetNode.start + focus.offset;\n      }\n    } else {\n      const node = focus.getNode().getDescendantByIndex(focusOffset);\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== focusOffset;\n          end = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n    return [start, end];\n  }\n}\nfunction $getAdjustedOffsetFromDiff(offset, offsetNode, prevOffsetView, offsetView, blockOffsetSize) {\n  const prevOffsetMap = prevOffsetView._offsetMap;\n  const offsetMap = offsetView._offsetMap;\n  const visited = new Set();\n  let adjustedOffset = offset;\n  let currentNode = offsetNode;\n  while (currentNode !== null) {\n    const key = currentNode.key;\n    const prevNode = prevOffsetMap.get(key);\n    const diff = currentNode.end - currentNode.start;\n    visited.add(key);\n    if (prevNode === undefined) {\n      adjustedOffset += diff;\n    } else {\n      const prevDiff = prevNode.end - prevNode.start;\n      if (prevDiff !== diff) {\n        adjustedOffset += diff - prevDiff;\n      }\n    }\n    const sibling = currentNode.prev;\n    if (sibling !== null) {\n      currentNode = sibling;\n      continue;\n    }\n    let parent = currentNode.parent;\n    while (parent !== null) {\n      let parentSibling = parent.prev;\n      if (parentSibling !== null) {\n        const parentSiblingKey = parentSibling.key;\n        const prevParentSibling = prevOffsetMap.get(parentSiblingKey);\n        const parentDiff = parentSibling.end - parentSibling.start;\n        visited.add(parentSiblingKey);\n        if (prevParentSibling === undefined) {\n          adjustedOffset += parentDiff;\n        } else {\n          const prevParentDiff = prevParentSibling.end - prevParentSibling.start;\n          if (prevParentDiff !== parentDiff) {\n            adjustedOffset += parentDiff - prevParentDiff;\n          }\n        }\n        parentSibling = parentSibling.prev;\n      }\n      parent = parent.parent;\n    }\n    break;\n  }\n\n  // Now traverse through the old offsets nodes and find any nodes we missed\n  // above, because they were not in the latest offset node view (they have been\n  // deleted).\n  const prevFirstNode = prevOffsetView._firstNode;\n  if (prevFirstNode !== null) {\n    currentNode = $searchForNodeWithOffset(prevFirstNode, offset, blockOffsetSize);\n    let alreadyVisitedParentOfCurrentNode = false;\n    while (currentNode !== null) {\n      if (!visited.has(currentNode.key)) {\n        alreadyVisitedParentOfCurrentNode = true;\n        break;\n      }\n      currentNode = currentNode.parent;\n    }\n    if (!alreadyVisitedParentOfCurrentNode) {\n      while (currentNode !== null) {\n        const key = currentNode.key;\n        if (!visited.has(key)) {\n          const node = offsetMap.get(key);\n          const prevDiff = currentNode.end - currentNode.start;\n          if (node === undefined) {\n            adjustedOffset -= prevDiff;\n          } else {\n            const diff = node.end - node.start;\n            if (prevDiff !== diff) {\n              adjustedOffset += diff - prevDiff;\n            }\n          }\n        }\n        currentNode = currentNode.prev;\n      }\n    }\n  }\n  return adjustedOffset;\n}\nfunction $searchForNodeWithOffset(firstNode, offset, blockOffsetSize) {\n  let currentNode = firstNode;\n  while (currentNode !== null) {\n    const end = currentNode.end + (currentNode.type !== 'element' || blockOffsetSize === 0 ? 1 : 0);\n    if (offset < end) {\n      const child = currentNode.child;\n      if (child !== null) {\n        currentNode = child;\n        continue;\n      }\n      return currentNode;\n    }\n    const sibling = currentNode.next;\n    if (sibling === null) {\n      break;\n    }\n    currentNode = sibling;\n  }\n  return null;\n}\nfunction $createInternalOffsetNode(child, type, start, end, key, parent) {\n  return {\n    child,\n    end,\n    key,\n    next: null,\n    parent,\n    prev: null,\n    start,\n    type\n  };\n}\nfunction $createOffsetNode(state, key, parent, nodeMap, offsetMap, blockOffsetSize) {\n  const node = nodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createOffsetModel: could not find node by key`);\n    }\n  }\n  const start = state.offset;\n  if ($isElementNode(node)) {\n    const childKeys = $createChildrenArray(node, nodeMap);\n    const blockIsEmpty = childKeys.length === 0;\n    const child = blockIsEmpty ? null : $createOffsetChild(state, childKeys, null, nodeMap, offsetMap, blockOffsetSize);\n\n    // If the prev node was not a block or the block is empty, we should\n    // account for the user being able to selection the block (due to the \\n).\n    if (!state.prevIsBlock || blockIsEmpty) {\n      state.prevIsBlock = true;\n      state.offset += blockOffsetSize;\n    }\n    const offsetNode = $createInternalOffsetNode(child, 'element', start, start, key, parent);\n    if (child !== null) {\n      child.parent = offsetNode;\n    }\n    const end = state.offset;\n    offsetNode.end = end;\n    offsetMap.set(key, offsetNode);\n    return offsetNode;\n  }\n  state.prevIsBlock = false;\n  const isText = $isTextNode(node);\n  const length = isText ? node.__text.length : 1;\n  const end = state.offset += length;\n  const offsetNode = $createInternalOffsetNode(null, isText ? 'text' : 'inline', start, end, key, parent);\n  offsetMap.set(key, offsetNode);\n  return offsetNode;\n}\nfunction $createOffsetChild(state, children, parent, nodeMap, offsetMap, blockOffsetSize) {\n  let firstNode = null;\n  let currentNode = null;\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const childKey = children[i];\n    const offsetNode = $createOffsetNode(state, childKey, parent, nodeMap, offsetMap, blockOffsetSize);\n    if (currentNode === null) {\n      firstNode = offsetNode;\n    } else {\n      offsetNode.prev = currentNode;\n      currentNode.next = offsetNode;\n    }\n    currentNode = offsetNode;\n  }\n  return firstNode;\n}\nfunction $createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap === null ? $getNodeByKey(nodeKey) : nodeMap.get(nodeKey);\n    if (node === null || node === undefined) {\n      {\n        throw Error(`$createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\n/** @deprecated renamed to {@link $createChildrenArray} by @lexical/eslint-plugin rules-of-lexical */\nconst createChildrenArray = $createChildrenArray;\nfunction $createOffsetView(editor, blockOffsetSize = 1, editorState) {\n  const targetEditorState = editorState || editor._pendingEditorState || editor._editorState;\n  const nodeMap = targetEditorState._nodeMap;\n  const root = nodeMap.get('root');\n  const offsetMap = new Map();\n  const state = {\n    offset: 0,\n    prevIsBlock: false\n  };\n  const node = $createOffsetChild(state, $createChildrenArray(root, nodeMap), null, nodeMap, offsetMap, blockOffsetSize);\n  return new OffsetView(offsetMap, node, blockOffsetSize);\n}\n\nexport { $createChildrenArray, $createOffsetView, OffsetView, createChildrenArray };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNodeByKey, $isLineBreakNode, $isTextNode, $getSelection, $isRangeSelection, createEditor, $getRoot, $isElementNode, $isRootNode, $isDecoratorNode, $createParagraphNode, createCommand } from 'lexical';\nimport { XmlText, Map as Map$1, XmlElement, Doc, createAbsolutePositionFromRelativePosition, createRelativePositionFromTypeIndex, compareRelativePositions, YTextEvent, YMapEvent, YXmlEvent, UndoManager } from 'yjs';\nimport { $createChildrenArray } from '@lexical/offset';\nimport { createDOMRange, createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabLineBreakNode {\n  constructor(map, parent) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._type = 'linebreak';\n  }\n  getNode() {\n    const node = $getNodeByKey(this._key);\n    return $isLineBreakNode(node) ? node : null;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSharedType() {\n    return this._map;\n  }\n  getType() {\n    return this._type;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabLineBreakNode(map, parent) {\n  const collabNode = new CollabLineBreakNode(map, parent);\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction simpleDiffWithCursor(a, b, cursor) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0; // number of same characters counting from left\n  let right = 0; // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n  while (left < aLength && left < bLength && a[left] === b[left] && left < cursor) {\n    left++;\n  }\n  // Iterate right to the left until we find a changed character\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  // Try to iterate left further to the right without caring about the current cursor position\n  while (right + left < aLength && right + left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  return {\n    index: left,\n    insert: b.slice(left, bLength - right),\n    remove: aLength - left - right\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $diffTextContentAndApplyDelta(collabNode, key, prevText, nextText) {\n  const selection = $getSelection();\n  let cursorOffset = nextText.length;\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    if (anchor.key === key) {\n      cursorOffset = anchor.offset;\n    }\n  }\n  const diff = simpleDiffWithCursor(prevText, nextText, cursorOffset);\n  collabNode.spliceText(diff.index, diff.remove, diff.insert);\n}\nclass CollabTextNode {\n  constructor(map, text, parent, type) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._text = text;\n    this._type = type;\n    this._normalized = false;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return $isTextNode(node) ? node : null;\n  }\n  getNode() {\n    const node = $getNodeByKey(this._key);\n    return $isTextNode(node) ? node : null;\n  }\n  getSharedType() {\n    return this._map;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSize() {\n    return this._text.length + (this._normalized ? 0 : 1);\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  spliceText(index, delCount, newText) {\n    const collabElementNode = this._parent;\n    const xmlText = collabElementNode._xmlText;\n    const offset = this.getOffset() + 1 + index;\n    if (delCount !== 0) {\n      xmlText.delete(offset, delCount);\n    }\n    if (newText !== '') {\n      xmlText.insert(offset, newText);\n    }\n  }\n  syncPropertiesAndTextFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const nextText = nextLexicalNode.__text;\n    syncPropertiesFromLexical(binding, this._map, prevLexicalNode, nextLexicalNode);\n    if (prevLexicalNode !== null) {\n      const prevText = prevLexicalNode.__text;\n      if (prevText !== nextText) {\n        const key = nextLexicalNode.__key;\n        $diffTextContentAndApplyDelta(this, key, prevText, nextText);\n        this._text = nextText;\n      }\n    }\n  }\n  syncPropertiesAndTextFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesAndTextFromYjs: could not find decorator node`);\n    }\n    syncPropertiesFromYjs(binding, this._map, lexicalNode, keysChanged);\n    const collabText = this._text;\n    if (lexicalNode.__text !== collabText) {\n      const writable = lexicalNode.getWritable();\n      writable.__text = collabText;\n    }\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabTextNode(map, text, parent, type) {\n  const collabNode = new CollabTextNode(map, text, parent, type);\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst baseExcludedProperties = new Set(['__key', '__parent', '__next', '__prev']);\nconst elementExcludedProperties = new Set(['__first', '__last', '__size']);\nconst rootExcludedProperties = new Set(['__cachedText']);\nconst textExcludedProperties = new Set(['__text']);\nfunction isExcludedProperty(name, node, binding) {\n  if (baseExcludedProperties.has(name)) {\n    return true;\n  }\n  if ($isTextNode(node)) {\n    if (textExcludedProperties.has(name)) {\n      return true;\n    }\n  } else if ($isElementNode(node)) {\n    if (elementExcludedProperties.has(name) || $isRootNode(node) && rootExcludedProperties.has(name)) {\n      return true;\n    }\n  }\n  const nodeKlass = node.constructor;\n  const excludedProperties = binding.excludedProperties.get(nodeKlass);\n  return excludedProperties != null && excludedProperties.has(name);\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (!(node !== null)) {\n    throw Error(`could not find node by key`);\n  }\n  return node;\n}\nfunction $createCollabNodeFromLexicalNode(binding, lexicalNode, parent) {\n  const nodeType = lexicalNode.__type;\n  let collabNode;\n  if ($isElementNode(lexicalNode)) {\n    const xmlText = new XmlText();\n    collabNode = $createCollabElementNode(xmlText, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n    collabNode.syncChildrenFromLexical(binding, lexicalNode, null, null, null);\n  } else if ($isTextNode(lexicalNode)) {\n    // TODO create a token text node for token, segmented nodes.\n    const map = new Map$1();\n    collabNode = $createCollabTextNode(map, lexicalNode.__text, parent, nodeType);\n    collabNode.syncPropertiesAndTextFromLexical(binding, lexicalNode, null);\n  } else if ($isLineBreakNode(lexicalNode)) {\n    const map = new Map$1();\n    map.set('__type', 'linebreak');\n    collabNode = $createCollabLineBreakNode(map, parent);\n  } else if ($isDecoratorNode(lexicalNode)) {\n    const xmlElem = new XmlElement();\n    collabNode = $createCollabDecoratorNode(xmlElem, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n  } else {\n    {\n      throw Error(`Expected text, element, decorator, or linebreak node`);\n    }\n  }\n  collabNode._key = lexicalNode.__key;\n  return collabNode;\n}\nfunction getNodeTypeFromSharedType(sharedType) {\n  const type = sharedType instanceof Map$1 ? sharedType.get('__type') : sharedType.getAttribute('__type');\n  if (!(type != null)) {\n    throw Error(`Expected shared type to include type attribute`);\n  }\n  return type;\n}\nfunction $getOrInitCollabNodeFromSharedType(binding, sharedType, parent) {\n  const collabNode = sharedType._collabNode;\n  if (collabNode === undefined) {\n    const registeredNodes = binding.editor._nodes;\n    const type = getNodeTypeFromSharedType(sharedType);\n    const nodeInfo = registeredNodes.get(type);\n    if (!(nodeInfo !== undefined)) {\n      throw Error(`Node ${type} is not registered`);\n    }\n    const sharedParent = sharedType.parent;\n    const targetParent = parent === undefined && sharedParent !== null ? $getOrInitCollabNodeFromSharedType(binding, sharedParent) : parent || null;\n    if (!(targetParent instanceof CollabElementNode)) {\n      throw Error(`Expected parent to be a collab element node`);\n    }\n    if (sharedType instanceof XmlText) {\n      return $createCollabElementNode(sharedType, targetParent, type);\n    } else if (sharedType instanceof Map$1) {\n      if (type === 'linebreak') {\n        return $createCollabLineBreakNode(sharedType, targetParent);\n      }\n      return $createCollabTextNode(sharedType, '', targetParent, type);\n    } else if (sharedType instanceof XmlElement) {\n      return $createCollabDecoratorNode(sharedType, targetParent, type);\n    }\n  }\n  return collabNode;\n}\nfunction createLexicalNodeFromCollabNode(binding, collabNode, parentKey) {\n  const type = collabNode.getType();\n  const registeredNodes = binding.editor._nodes;\n  const nodeInfo = registeredNodes.get(type);\n  if (!(nodeInfo !== undefined)) {\n    throw Error(`Node ${type} is not registered`);\n  }\n  const lexicalNode = new nodeInfo.klass();\n  lexicalNode.__parent = parentKey;\n  collabNode._key = lexicalNode.__key;\n  if (collabNode instanceof CollabElementNode) {\n    const xmlText = collabNode._xmlText;\n    collabNode.syncPropertiesFromYjs(binding, null);\n    collabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n    collabNode.syncChildrenFromYjs(binding);\n  } else if (collabNode instanceof CollabTextNode) {\n    collabNode.syncPropertiesAndTextFromYjs(binding, null);\n  } else if (collabNode instanceof CollabDecoratorNode) {\n    collabNode.syncPropertiesFromYjs(binding, null);\n  }\n  binding.collabNodeMap.set(lexicalNode.__key, collabNode);\n  return lexicalNode;\n}\nfunction syncPropertiesFromYjs(binding, sharedType, lexicalNode, keysChanged) {\n  const properties = keysChanged === null ? sharedType instanceof Map$1 ? Array.from(sharedType.keys()) : Object.keys(sharedType.getAttributes()) : Array.from(keysChanged);\n  let writableNode;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (isExcludedProperty(property, lexicalNode, binding)) {\n      continue;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const prevValue = lexicalNode[property];\n    let nextValue = sharedType instanceof Map$1 ? sharedType.get(property) : sharedType.getAttribute(property);\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof Doc) {\n        const yjsDocMap = binding.docMap;\n        if (prevValue instanceof Doc) {\n          yjsDocMap.delete(prevValue.guid);\n        }\n        const nestedEditor = createEditor();\n        const key = nextValue.guid;\n        nestedEditor._key = key;\n        yjsDocMap.set(key, nextValue);\n        nextValue = nestedEditor;\n      }\n      if (writableNode === undefined) {\n        writableNode = lexicalNode.getWritable();\n      }\n      writableNode[property] = nextValue;\n    }\n  }\n}\nfunction syncPropertiesFromLexical(binding, sharedType, prevLexicalNode, nextLexicalNode) {\n  const type = nextLexicalNode.__type;\n  const nodeProperties = binding.nodeProperties;\n  let properties = nodeProperties.get(type);\n  if (properties === undefined) {\n    properties = Object.keys(nextLexicalNode).filter(property => {\n      return !isExcludedProperty(property, nextLexicalNode, binding);\n    });\n    nodeProperties.set(type, properties);\n  }\n  const EditorClass = binding.editor.constructor;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    const prevValue =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    prevLexicalNode === null ? undefined : prevLexicalNode[property];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextValue = nextLexicalNode[property];\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof EditorClass) {\n        const yjsDocMap = binding.docMap;\n        let prevDoc;\n        if (prevValue instanceof EditorClass) {\n          const prevKey = prevValue._key;\n          prevDoc = yjsDocMap.get(prevKey);\n          yjsDocMap.delete(prevKey);\n        }\n\n        // If we already have a document, use it.\n        const doc = prevDoc || new Doc();\n        const key = doc.guid;\n        nextValue._key = key;\n        yjsDocMap.set(key, doc);\n        nextValue = doc;\n        // Mark the node dirty as we've assigned a new key to it\n        binding.editor.update(() => {\n          nextLexicalNode.markDirty();\n        });\n      }\n      if (sharedType instanceof Map$1) {\n        sharedType.set(property, nextValue);\n      } else {\n        sharedType.setAttribute(property, nextValue);\n      }\n    }\n  }\n}\nfunction spliceString(str, index, delCount, newText) {\n  return str.slice(0, index) + newText + str.slice(index + delCount);\n}\nfunction getPositionFromElementAndOffset(node, offset, boundaryIsEdge) {\n  let index = 0;\n  let i = 0;\n  const children = node._children;\n  const childrenLength = children.length;\n  for (; i < childrenLength; i++) {\n    const child = children[i];\n    const childOffset = index;\n    const size = child.getSize();\n    index += size;\n    const exceedsBoundary = boundaryIsEdge ? index >= offset : index > offset;\n    if (exceedsBoundary && child instanceof CollabTextNode) {\n      let textOffset = offset - childOffset - 1;\n      if (textOffset < 0) {\n        textOffset = 0;\n      }\n      const diffLength = index - offset;\n      return {\n        length: diffLength,\n        node: child,\n        nodeIndex: i,\n        offset: textOffset\n      };\n    }\n    if (index > offset) {\n      return {\n        length: 0,\n        node: child,\n        nodeIndex: i,\n        offset: childOffset\n      };\n    } else if (i === childrenLength - 1) {\n      return {\n        length: 0,\n        node: null,\n        nodeIndex: i + 1,\n        offset: childOffset + 1\n      };\n    }\n  }\n  return {\n    length: 0,\n    node: null,\n    nodeIndex: 0,\n    offset: 0\n  };\n}\nfunction doesSelectionNeedRecovering(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let recoveryNeeded = false;\n  try {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (\n    // We might have removed a node that no longer exists\n    !anchorNode.isAttached() || !focusNode.isAttached() ||\n    // If we've split a node, then the offset might not be right\n    $isTextNode(anchorNode) && anchor.offset > anchorNode.getTextContentSize() || $isTextNode(focusNode) && focus.offset > focusNode.getTextContentSize()) {\n      recoveryNeeded = true;\n    }\n  } catch (e) {\n    // Sometimes checking nor a node via getNode might trigger\n    // an error, so we need recovery then too.\n    recoveryNeeded = true;\n  }\n  return recoveryNeeded;\n}\nfunction syncWithTransaction(binding, fn) {\n  binding.doc.transact(fn, binding);\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\nfunction $moveSelectionToPreviousNode(anchorNodeKey, currentEditorState) {\n  const anchorNode = currentEditorState._nodeMap.get(anchorNodeKey);\n  if (!anchorNode) {\n    $getRoot().selectStart();\n    return;\n  }\n  // Get previous node\n  const prevNodeKey = anchorNode.__prev;\n  let prevNode = null;\n  if (prevNodeKey) {\n    prevNode = $getNodeByKey(prevNodeKey);\n  }\n\n  // If previous node not found, get parent node\n  if (prevNode === null && anchorNode.__parent !== null) {\n    prevNode = $getNodeByKey(anchorNode.__parent);\n  }\n  if (prevNode === null) {\n    $getRoot().selectStart();\n    return;\n  }\n  if (prevNode !== null && prevNode.isAttached()) {\n    prevNode.selectEnd();\n    return;\n  } else {\n    // If the found node is also deleted, select the next one\n    $moveSelectionToPreviousNode(prevNode.__key, currentEditorState);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabDecoratorNode {\n  constructor(xmlElem, parent, type) {\n    this._key = '';\n    this._xmlElem = xmlElem;\n    this._parent = parent;\n    this._type = type;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return $isDecoratorNode(node) ? node : null;\n  }\n  getNode() {\n    const node = $getNodeByKey(this._key);\n    return $isDecoratorNode(node) ? node : null;\n  }\n  getSharedType() {\n    return this._xmlElem;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromLexical(binding, xmlElem, prevLexicalNode, nextLexicalNode);\n  }\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: could not find decorator node`);\n    }\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromYjs(binding, xmlElem, lexicalNode, keysChanged);\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabDecoratorNode(xmlElem, parent, type) {\n  const collabNode = new CollabDecoratorNode(xmlElem, parent, type);\n  xmlElem._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass CollabElementNode {\n  constructor(xmlText, parent, type) {\n    this._key = '';\n    this._children = [];\n    this._xmlText = xmlText;\n    this._type = type;\n    this._parent = parent;\n  }\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n    const node = nodeMap.get(this._key);\n    return $isElementNode(node) ? node : null;\n  }\n  getNode() {\n    const node = $getNodeByKey(this._key);\n    return $isElementNode(node) ? node : null;\n  }\n  getSharedType() {\n    return this._xmlText;\n  }\n  getType() {\n    return this._type;\n  }\n  getKey() {\n    return this._key;\n  }\n  isEmpty() {\n    return this._children.length === 0;\n  }\n  getSize() {\n    return 1;\n  }\n  getOffset() {\n    const collabElementNode = this._parent;\n    if (!(collabElementNode !== null)) {\n      throw Error(`getOffset: could not find collab element node`);\n    }\n    return collabElementNode.getChildOffset(this);\n  }\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: could not find element node`);\n    }\n    syncPropertiesFromYjs(binding, this._xmlText, lexicalNode, keysChanged);\n  }\n  applyChildrenYjsDelta(binding, deltas) {\n    const children = this._children;\n    let currIndex = 0;\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i];\n      const insertDelta = delta.insert;\n      const deleteDelta = delta.delete;\n      if (delta.retain != null) {\n        currIndex += delta.retain;\n      } else if (typeof deleteDelta === 'number') {\n        let deletionSize = deleteDelta;\n        while (deletionSize > 0) {\n          const {\n            node,\n            nodeIndex,\n            offset,\n            length\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n          if (node instanceof CollabElementNode || node instanceof CollabLineBreakNode || node instanceof CollabDecoratorNode) {\n            children.splice(nodeIndex, 1);\n            deletionSize -= 1;\n          } else if (node instanceof CollabTextNode) {\n            const delCount = Math.min(deletionSize, length);\n            const prevCollabNode = nodeIndex !== 0 ? children[nodeIndex - 1] : null;\n            const nodeSize = node.getSize();\n            if (offset === 0 && length === nodeSize) {\n              // Text node has been deleted.\n              children.splice(nodeIndex, 1);\n              // If this was caused by an undo from YJS, there could be dangling text.\n              const danglingText = spliceString(node._text, offset, delCount - 1, '');\n              if (danglingText.length > 0) {\n                if (prevCollabNode instanceof CollabTextNode) {\n                  // Merge the text node with previous.\n                  prevCollabNode._text += danglingText;\n                } else {\n                  // No previous text node to merge into, just delete the text.\n                  this._xmlText.delete(offset, danglingText.length);\n                }\n              }\n            } else {\n              node._text = spliceString(node._text, offset, delCount, '');\n            }\n            deletionSize -= delCount;\n          } else {\n            // Can occur due to the deletion from the dangling text heuristic below.\n            break;\n          }\n        }\n      } else if (insertDelta != null) {\n        if (typeof insertDelta === 'string') {\n          const {\n            node,\n            offset\n          } = getPositionFromElementAndOffset(this, currIndex, true);\n          if (node instanceof CollabTextNode) {\n            node._text = spliceString(node._text, offset, 0, insertDelta);\n          } else {\n            // TODO: maybe we can improve this by keeping around a redundant\n            // text node map, rather than removing all the text nodes, so there\n            // never can be dangling text.\n\n            // We have a conflict where there was likely a CollabTextNode and\n            // an Lexical TextNode too, but they were removed in a merge. So\n            // let's just ignore the text and trigger a removal for it from our\n            // shared type.\n            this._xmlText.delete(offset, insertDelta.length);\n          }\n          currIndex += insertDelta.length;\n        } else {\n          const sharedType = insertDelta;\n          const {\n            nodeIndex\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n          const collabNode = $getOrInitCollabNodeFromSharedType(binding, sharedType, this);\n          children.splice(nodeIndex, 0, collabNode);\n          currIndex += 1;\n        }\n      } else {\n        throw new Error('Unexpected delta format');\n      }\n    }\n  }\n  syncChildrenFromYjs(binding) {\n    // Now diff the children of the collab node with that of our existing Lexical node.\n    const lexicalNode = this.getNode();\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncChildrenFromYjs: could not find element node`);\n    }\n    const key = lexicalNode.__key;\n    const prevLexicalChildrenKeys = $createChildrenArray(lexicalNode, null);\n    const lexicalChildrenKeysLength = prevLexicalChildrenKeys.length;\n    const collabChildren = this._children;\n    const collabChildrenLength = collabChildren.length;\n    const collabNodeMap = binding.collabNodeMap;\n    const visitedKeys = new Set();\n    let collabKeys;\n    let writableLexicalNode;\n    let prevIndex = 0;\n    let prevChildNode = null;\n    if (collabChildrenLength !== lexicalChildrenKeysLength) {\n      writableLexicalNode = lexicalNode.getWritable();\n    }\n    for (let i = 0; i < collabChildrenLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[prevIndex];\n      const childCollabNode = collabChildren[i];\n      const collabLexicalChildNode = childCollabNode.getNode();\n      const collabKey = childCollabNode._key;\n      if (collabLexicalChildNode !== null && lexicalChildKey === collabKey) {\n        const childNeedsUpdating = $isTextNode(collabLexicalChildNode);\n        // Update\n        visitedKeys.add(lexicalChildKey);\n        if (childNeedsUpdating) {\n          childCollabNode._key = lexicalChildKey;\n          if (childCollabNode instanceof CollabElementNode) {\n            const xmlText = childCollabNode._xmlText;\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n            childCollabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n            childCollabNode.syncChildrenFromYjs(binding);\n          } else if (childCollabNode instanceof CollabTextNode) {\n            childCollabNode.syncPropertiesAndTextFromYjs(binding, null);\n          } else if (childCollabNode instanceof CollabDecoratorNode) {\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n          } else if (!(childCollabNode instanceof CollabLineBreakNode)) {\n            {\n              throw Error(`syncChildrenFromYjs: expected text, element, decorator, or linebreak collab node`);\n            }\n          }\n        }\n        prevChildNode = collabLexicalChildNode;\n        prevIndex++;\n      } else {\n        if (collabKeys === undefined) {\n          collabKeys = new Set();\n          for (let s = 0; s < collabChildrenLength; s++) {\n            const child = collabChildren[s];\n            const childKey = child._key;\n            if (childKey !== '') {\n              collabKeys.add(childKey);\n            }\n          }\n        }\n        if (collabLexicalChildNode !== null && lexicalChildKey !== undefined && !collabKeys.has(lexicalChildKey)) {\n          const nodeToRemove = $getNodeByKeyOrThrow(lexicalChildKey);\n          removeFromParent(nodeToRemove);\n          i--;\n          prevIndex++;\n          continue;\n        }\n        writableLexicalNode = lexicalNode.getWritable();\n        // Create/Replace\n        const lexicalChildNode = createLexicalNodeFromCollabNode(binding, childCollabNode, key);\n        const childKey = lexicalChildNode.__key;\n        collabNodeMap.set(childKey, childCollabNode);\n        if (prevChildNode === null) {\n          const nextSibling = writableLexicalNode.getFirstChild();\n          writableLexicalNode.__first = childKey;\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        } else {\n          const writablePrevChildNode = prevChildNode.getWritable();\n          const nextSibling = prevChildNode.getNextSibling();\n          writablePrevChildNode.__next = childKey;\n          lexicalChildNode.__prev = prevChildNode.__key;\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        }\n        if (i === collabChildrenLength - 1) {\n          writableLexicalNode.__last = childKey;\n        }\n        writableLexicalNode.__size++;\n        prevChildNode = lexicalChildNode;\n      }\n    }\n    for (let i = 0; i < lexicalChildrenKeysLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[i];\n      if (!visitedKeys.has(lexicalChildKey)) {\n        // Remove\n        const lexicalChildNode = $getNodeByKeyOrThrow(lexicalChildKey);\n        const collabNode = binding.collabNodeMap.get(lexicalChildKey);\n        if (collabNode !== undefined) {\n          collabNode.destroy(binding);\n        }\n        removeFromParent(lexicalChildNode);\n      }\n    }\n  }\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    syncPropertiesFromLexical(binding, this._xmlText, this.getPrevNode(prevNodeMap), nextLexicalNode);\n  }\n  _syncChildFromLexical(binding, index, key, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const childCollabNode = this._children[index];\n    // Update\n    const nextChildNode = $getNodeByKeyOrThrow(key);\n    if (childCollabNode instanceof CollabElementNode && $isElementNode(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n      childCollabNode.syncChildrenFromLexical(binding, nextChildNode, prevNodeMap, dirtyElements, dirtyLeaves);\n    } else if (childCollabNode instanceof CollabTextNode && $isTextNode(nextChildNode)) {\n      childCollabNode.syncPropertiesAndTextFromLexical(binding, nextChildNode, prevNodeMap);\n    } else if (childCollabNode instanceof CollabDecoratorNode && $isDecoratorNode(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n    }\n  }\n  syncChildrenFromLexical(binding, nextLexicalNode, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const prevChildren = prevLexicalNode === null ? [] : $createChildrenArray(prevLexicalNode, prevNodeMap);\n    const nextChildren = $createChildrenArray(nextLexicalNode, null);\n    const prevEndIndex = prevChildren.length - 1;\n    const nextEndIndex = nextChildren.length - 1;\n    const collabNodeMap = binding.collabNodeMap;\n    let prevChildrenSet;\n    let nextChildrenSet;\n    let prevIndex = 0;\n    let nextIndex = 0;\n    while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n      const prevKey = prevChildren[prevIndex];\n      const nextKey = nextChildren[nextIndex];\n      if (prevKey === nextKey) {\n        // Nove move, create or remove\n        this._syncChildFromLexical(binding, nextIndex, nextKey, prevNodeMap, dirtyElements, dirtyLeaves);\n        prevIndex++;\n        nextIndex++;\n      } else {\n        if (prevChildrenSet === undefined) {\n          prevChildrenSet = new Set(prevChildren);\n        }\n        if (nextChildrenSet === undefined) {\n          nextChildrenSet = new Set(nextChildren);\n        }\n        const nextHasPrevKey = nextChildrenSet.has(prevKey);\n        const prevHasNextKey = prevChildrenSet.has(nextKey);\n        if (!nextHasPrevKey) {\n          // Remove\n          this.splice(binding, nextIndex, 1);\n          prevIndex++;\n        } else {\n          // Create or replace\n          const nextChildNode = $getNodeByKeyOrThrow(nextKey);\n          const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n          collabNodeMap.set(nextKey, collabNode);\n          if (prevHasNextKey) {\n            this.splice(binding, nextIndex, 1, collabNode);\n            prevIndex++;\n            nextIndex++;\n          } else {\n            this.splice(binding, nextIndex, 0, collabNode);\n            nextIndex++;\n          }\n        }\n      }\n    }\n    const appendNewChildren = prevIndex > prevEndIndex;\n    const removeOldChildren = nextIndex > nextEndIndex;\n    if (appendNewChildren && !removeOldChildren) {\n      for (; nextIndex <= nextEndIndex; ++nextIndex) {\n        const key = nextChildren[nextIndex];\n        const nextChildNode = $getNodeByKeyOrThrow(key);\n        const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n        this.append(collabNode);\n        collabNodeMap.set(key, collabNode);\n      }\n    } else if (removeOldChildren && !appendNewChildren) {\n      for (let i = this._children.length - 1; i >= nextIndex; i--) {\n        this.splice(binding, i, 1);\n      }\n    }\n  }\n  append(collabNode) {\n    const xmlText = this._xmlText;\n    const children = this._children;\n    const lastChild = children[children.length - 1];\n    const offset = lastChild !== undefined ? lastChild.getOffset() + lastChild.getSize() : 0;\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n    this._children.push(collabNode);\n  }\n  splice(binding, index, delCount, collabNode) {\n    const children = this._children;\n    const child = children[index];\n    if (child === undefined) {\n      if (!(collabNode !== undefined)) {\n        throw Error(`splice: could not find collab element node`);\n      }\n      this.append(collabNode);\n      return;\n    }\n    const offset = child.getOffset();\n    if (!(offset !== -1)) {\n      throw Error(`splice: expected offset to be greater than zero`);\n    }\n    const xmlText = this._xmlText;\n    if (delCount !== 0) {\n      // What if we delete many nodes, don't we need to get all their\n      // sizes?\n      xmlText.delete(offset, child.getSize());\n    }\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n    if (delCount !== 0) {\n      const childrenToDelete = children.slice(index, index + delCount);\n      for (let i = 0; i < childrenToDelete.length; i++) {\n        childrenToDelete[i].destroy(binding);\n      }\n    }\n    if (collabNode !== undefined) {\n      children.splice(index, delCount, collabNode);\n    } else {\n      children.splice(index, delCount);\n    }\n  }\n  getChildOffset(collabNode) {\n    let offset = 0;\n    const children = this._children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child === collabNode) {\n        return offset;\n      }\n      offset += child.getSize();\n    }\n    return -1;\n  }\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    const children = this._children;\n    for (let i = 0; i < children.length; i++) {\n      children[i].destroy(binding);\n    }\n    collabNodeMap.delete(this._key);\n  }\n}\nfunction $createCollabElementNode(xmlText, parent, type) {\n  const collabNode = new CollabElementNode(xmlText, parent, type);\n  xmlText._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createBinding(editor, provider, id, doc, docMap, excludedProperties) {\n  if (!(doc !== undefined && doc !== null)) {\n    throw Error(`createBinding: doc is null or undefined`);\n  }\n  const rootXmlText = doc.get('root', XmlText);\n  const root = $createCollabElementNode(rootXmlText, null, 'root');\n  root._key = 'root';\n  return {\n    clientID: doc.clientID,\n    collabNodeMap: new Map(),\n    cursors: new Map(),\n    cursorsContainer: null,\n    doc,\n    docMap,\n    editor,\n    excludedProperties: excludedProperties || new Map(),\n    id,\n    nodeProperties: new Map(),\n    root\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createRelativePosition(point, binding) {\n  const collabNodeMap = binding.collabNodeMap;\n  const collabNode = collabNodeMap.get(point.key);\n  if (collabNode === undefined) {\n    return null;\n  }\n  let offset = point.offset;\n  let sharedType = collabNode.getSharedType();\n  if (collabNode instanceof CollabTextNode) {\n    sharedType = collabNode._parent._xmlText;\n    const currentOffset = collabNode.getOffset();\n    if (currentOffset === -1) {\n      return null;\n    }\n    offset = currentOffset + 1 + offset;\n  } else if (collabNode instanceof CollabElementNode && point.type === 'element') {\n    const parent = point.getNode();\n    if (!$isElementNode(parent)) {\n      throw Error(`Element point must be an element node`);\n    }\n    let accumulatedOffset = 0;\n    let i = 0;\n    let node = parent.getFirstChild();\n    while (node !== null && i++ < offset) {\n      if ($isTextNode(node)) {\n        accumulatedOffset += node.getTextContentSize() + 1;\n      } else {\n        accumulatedOffset++;\n      }\n      node = node.getNextSibling();\n    }\n    offset = accumulatedOffset;\n  }\n  return createRelativePositionFromTypeIndex(sharedType, offset);\n}\nfunction createAbsolutePosition(relativePosition, binding) {\n  return createAbsolutePositionFromRelativePosition(relativePosition, binding.doc);\n}\nfunction shouldUpdatePosition(currentPos, pos) {\n  if (currentPos == null) {\n    if (pos != null) {\n      return true;\n    }\n  } else if (pos == null || !compareRelativePositions(currentPos, pos)) {\n    return true;\n  }\n  return false;\n}\nfunction createCursor(name, color) {\n  return {\n    color: color,\n    name: name,\n    selection: null\n  };\n}\nfunction destroySelection(binding, selection) {\n  const cursorsContainer = binding.cursorsContainer;\n  if (cursorsContainer !== null) {\n    const selections = selection.selections;\n    const selectionsLength = selections.length;\n    for (let i = 0; i < selectionsLength; i++) {\n      cursorsContainer.removeChild(selections[i]);\n    }\n  }\n}\nfunction destroyCursor(binding, cursor) {\n  const selection = cursor.selection;\n  if (selection !== null) {\n    destroySelection(binding, selection);\n  }\n}\nfunction createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset) {\n  const color = cursor.color;\n  const caret = document.createElement('span');\n  caret.style.cssText = `position:absolute;top:0;bottom:0;right:-1px;width:1px;background-color:${color};z-index:10;`;\n  const name = document.createElement('span');\n  name.textContent = cursor.name;\n  name.style.cssText = `position:absolute;left:-2px;top:-16px;background-color:${color};color:#fff;line-height:12px;font-size:12px;padding:2px;font-family:Arial;font-weight:bold;white-space:nowrap;`;\n  caret.appendChild(name);\n  return {\n    anchor: {\n      key: anchorKey,\n      offset: anchorOffset\n    },\n    caret,\n    color,\n    focus: {\n      key: focusKey,\n      offset: focusOffset\n    },\n    name,\n    selections: []\n  };\n}\nfunction updateCursor(binding, cursor, nextSelection, nodeMap) {\n  const editor = binding.editor;\n  const rootElement = editor.getRootElement();\n  const cursorsContainer = binding.cursorsContainer;\n  if (cursorsContainer === null || rootElement === null) {\n    return;\n  }\n  const cursorsContainerOffsetParent = cursorsContainer.offsetParent;\n  if (cursorsContainerOffsetParent === null) {\n    return;\n  }\n  const containerRect = cursorsContainerOffsetParent.getBoundingClientRect();\n  const prevSelection = cursor.selection;\n  if (nextSelection === null) {\n    if (prevSelection === null) {\n      return;\n    } else {\n      cursor.selection = null;\n      destroySelection(binding, prevSelection);\n      return;\n    }\n  } else {\n    cursor.selection = nextSelection;\n  }\n  const caret = nextSelection.caret;\n  const color = nextSelection.color;\n  const selections = nextSelection.selections;\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorNode = nodeMap.get(anchorKey);\n  const focusNode = nodeMap.get(focusKey);\n  if (anchorNode == null || focusNode == null) {\n    return;\n  }\n  let selectionRects;\n\n  // In the case of a collapsed selection on a linebreak, we need\n  // to improvise as the browser will return nothing here as <br>\n  // apparantly take up no visual space :/\n  // This won't work in all cases, but it's better than just showing\n  // nothing all the time.\n  if (anchorNode === focusNode && $isLineBreakNode(anchorNode)) {\n    const brRect = editor.getElementByKey(anchorKey).getBoundingClientRect();\n    selectionRects = [brRect];\n  } else {\n    const range = createDOMRange(editor, anchorNode, anchor.offset, focusNode, focus.offset);\n    if (range === null) {\n      return;\n    }\n    selectionRects = createRectsFromDOMRange(editor, range);\n  }\n  const selectionsLength = selections.length;\n  const selectionRectsLength = selectionRects.length;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    let selection = selections[i];\n    if (selection === undefined) {\n      selection = document.createElement('span');\n      selections[i] = selection;\n      const selectionBg = document.createElement('span');\n      selection.appendChild(selectionBg);\n      cursorsContainer.appendChild(selection);\n    }\n    const top = selectionRect.top - containerRect.top;\n    const left = selectionRect.left - containerRect.left;\n    const style = `position:absolute;top:${top}px;left:${left}px;height:${selectionRect.height}px;width:${selectionRect.width}px;pointer-events:none;z-index:5;`;\n    selection.style.cssText = style;\n    selection.firstChild.style.cssText = `${style}left:0;top:0;background-color:${color};opacity:0.3;`;\n    if (i === selectionRectsLength - 1) {\n      if (caret.parentNode !== selection) {\n        selection.appendChild(caret);\n      }\n    }\n  }\n  for (let i = selectionsLength - 1; i >= selectionRectsLength; i--) {\n    const selection = selections[i];\n    cursorsContainer.removeChild(selection);\n    selections.pop();\n  }\n}\nfunction $syncLocalCursorPosition(binding, provider) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n  if (localState === null) {\n    return;\n  }\n  const anchorPos = localState.anchorPos;\n  const focusPos = localState.focusPos;\n  if (anchorPos !== null && focusPos !== null) {\n    const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n    const focusAbsPos = createAbsolutePosition(focusPos, binding);\n    if (anchorAbsPos !== null && focusAbsPos !== null) {\n      const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n      const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n      if (anchorCollabNode !== null && focusCollabNode !== null) {\n        const anchorKey = anchorCollabNode.getKey();\n        const focusKey = focusCollabNode.getKey();\n        const selection = $getSelection();\n        if (!$isRangeSelection(selection)) {\n          return;\n        }\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        $setPoint(anchor, anchorKey, anchorOffset);\n        $setPoint(focus, focusKey, focusOffset);\n      }\n    }\n  }\n}\nfunction $setPoint(point, key, offset) {\n  if (point.key !== key || point.offset !== offset) {\n    let anchorNode = $getNodeByKey(key);\n    if (anchorNode !== null && !$isElementNode(anchorNode) && !$isTextNode(anchorNode)) {\n      const parent = anchorNode.getParentOrThrow();\n      key = parent.getKey();\n      offset = anchorNode.getIndexWithinParent();\n      anchorNode = parent;\n    }\n    point.set(key, offset, $isElementNode(anchorNode) ? 'element' : 'text');\n  }\n}\nfunction getCollabNodeAndOffset(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nsharedType, offset) {\n  const collabNode = sharedType._collabNode;\n  if (collabNode === undefined) {\n    return [null, 0];\n  }\n  if (collabNode instanceof CollabElementNode) {\n    const {\n      node,\n      offset: collabNodeOffset\n    } = getPositionFromElementAndOffset(collabNode, offset, true);\n    if (node === null) {\n      return [collabNode, 0];\n    } else {\n      return [node, collabNodeOffset];\n    }\n  }\n  return [null, 0];\n}\nfunction syncCursorPositions(binding, provider) {\n  const awarenessStates = Array.from(provider.awareness.getStates());\n  const localClientID = binding.clientID;\n  const cursors = binding.cursors;\n  const editor = binding.editor;\n  const nodeMap = editor._editorState._nodeMap;\n  const visitedClientIDs = new Set();\n  for (let i = 0; i < awarenessStates.length; i++) {\n    const awarenessState = awarenessStates[i];\n    const [clientID, awareness] = awarenessState;\n    if (clientID !== localClientID) {\n      visitedClientIDs.add(clientID);\n      const {\n        anchorPos,\n        focusPos,\n        name,\n        color,\n        focusing\n      } = awareness;\n      let selection = null;\n      let cursor = cursors.get(clientID);\n      if (cursor === undefined) {\n        cursor = createCursor(name, color);\n        cursors.set(clientID, cursor);\n      }\n      if (anchorPos !== null && focusPos !== null && focusing) {\n        const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n        const focusAbsPos = createAbsolutePosition(focusPos, binding);\n        if (anchorAbsPos !== null && focusAbsPos !== null) {\n          const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n          const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n          if (anchorCollabNode !== null && focusCollabNode !== null) {\n            const anchorKey = anchorCollabNode.getKey();\n            const focusKey = focusCollabNode.getKey();\n            selection = cursor.selection;\n            if (selection === null) {\n              selection = createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset);\n            } else {\n              const anchor = selection.anchor;\n              const focus = selection.focus;\n              anchor.key = anchorKey;\n              anchor.offset = anchorOffset;\n              focus.key = focusKey;\n              focus.offset = focusOffset;\n            }\n          }\n        }\n      }\n      updateCursor(binding, cursor, selection, nodeMap);\n    }\n  }\n  const allClientIDs = Array.from(cursors.keys());\n  for (let i = 0; i < allClientIDs.length; i++) {\n    const clientID = allClientIDs[i];\n    if (!visitedClientIDs.has(clientID)) {\n      const cursor = cursors.get(clientID);\n      if (cursor !== undefined) {\n        destroyCursor(binding, cursor);\n        cursors.delete(clientID);\n      }\n    }\n  }\n}\nfunction syncLexicalSelectionToYjs(binding, provider, prevSelection, nextSelection) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n  if (localState === null) {\n    return;\n  }\n  const {\n    anchorPos: currentAnchorPos,\n    focusPos: currentFocusPos,\n    name,\n    color,\n    focusing,\n    awarenessData\n  } = localState;\n  let anchorPos = null;\n  let focusPos = null;\n  if (nextSelection === null || currentAnchorPos !== null && !nextSelection.is(prevSelection)) {\n    if (prevSelection === null) {\n      return;\n    }\n  }\n  if ($isRangeSelection(nextSelection)) {\n    anchorPos = createRelativePosition(nextSelection.anchor, binding);\n    focusPos = createRelativePosition(nextSelection.focus, binding);\n  }\n  if (shouldUpdatePosition(currentAnchorPos, anchorPos) || shouldUpdatePosition(currentFocusPos, focusPos)) {\n    awareness.setLocalState({\n      ...localState,\n      anchorPos,\n      awarenessData,\n      color,\n      focusPos,\n      focusing,\n      name\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction $syncEvent(binding, event) {\n  const {\n    target\n  } = event;\n  const collabNode = $getOrInitCollabNodeFromSharedType(binding, target);\n  if (collabNode instanceof CollabElementNode && event instanceof YTextEvent) {\n    // @ts-expect-error We need to access the private property of the class\n    const {\n      keysChanged,\n      childListChanged,\n      delta\n    } = event;\n\n    // Update\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, keysChanged);\n    }\n    if (childListChanged) {\n      collabNode.applyChildrenYjsDelta(binding, delta);\n      collabNode.syncChildrenFromYjs(binding);\n    }\n  } else if (collabNode instanceof CollabTextNode && event instanceof YMapEvent) {\n    const {\n      keysChanged\n    } = event;\n\n    // Update\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesAndTextFromYjs(binding, keysChanged);\n    }\n  } else if (collabNode instanceof CollabDecoratorNode && event instanceof YXmlEvent) {\n    const {\n      attributesChanged\n    } = event;\n\n    // Update\n    if (attributesChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, attributesChanged);\n    }\n  } else {\n    {\n      throw Error(`Expected text, element, or decorator event`);\n    }\n  }\n}\nfunction syncYjsChangesToLexical(binding, provider, events, isFromUndoManger) {\n  const editor = binding.editor;\n  const currentEditorState = editor._editorState;\n\n  // This line precompute the delta before editor update. The reason is\n  // delta is computed when it is accessed. Note that this can only be\n  // safely computed during the event call. If it is accessed after event\n  // call it might result in unexpected behavior.\n  // https://github.com/yjs/yjs/blob/00ef472d68545cb260abd35c2de4b3b78719c9e4/src/utils/YEvent.js#L132\n  events.forEach(event => event.delta);\n  editor.update(() => {\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      $syncEvent(binding, event);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      if (doesSelectionNeedRecovering(selection)) {\n        const prevSelection = currentEditorState._selection;\n        if ($isRangeSelection(prevSelection)) {\n          $syncLocalCursorPosition(binding, provider);\n          if (doesSelectionNeedRecovering(selection)) {\n            // If the selected node is deleted, move the selection to the previous or parent node.\n            const anchorNodeKey = selection.anchor.key;\n            $moveSelectionToPreviousNode(anchorNodeKey, currentEditorState);\n          }\n        }\n        syncLexicalSelectionToYjs(binding, provider, prevSelection, $getSelection());\n      } else {\n        $syncLocalCursorPosition(binding, provider);\n      }\n    }\n  }, {\n    onUpdate: () => {\n      syncCursorPositions(binding, provider);\n      // If there was a collision on the top level paragraph\n      // we need to re-add a paragraph. To ensure this insertion properly syncs with other clients,\n      // it must be placed outside of the update block above that has tags 'collaboration' or 'historic'.\n      editor.update(() => {\n        if ($getRoot().getChildrenSize() === 0) {\n          $getRoot().append($createParagraphNode());\n        }\n      });\n    },\n    skipTransforms: true,\n    tag: isFromUndoManger ? 'historic' : 'collaboration'\n  });\n}\nfunction $handleNormalizationMergeConflicts(binding, normalizedNodes) {\n  // We handle the merge operations here\n  const normalizedNodesKeys = Array.from(normalizedNodes);\n  const collabNodeMap = binding.collabNodeMap;\n  const mergedNodes = [];\n  for (let i = 0; i < normalizedNodesKeys.length; i++) {\n    const nodeKey = normalizedNodesKeys[i];\n    const lexicalNode = $getNodeByKey(nodeKey);\n    const collabNode = collabNodeMap.get(nodeKey);\n    if (collabNode instanceof CollabTextNode) {\n      if ($isTextNode(lexicalNode)) {\n        // We mutate the text collab nodes after removing\n        // all the dead nodes first, otherwise offsets break.\n        mergedNodes.push([collabNode, lexicalNode.__text]);\n      } else {\n        const offset = collabNode.getOffset();\n        if (offset === -1) {\n          continue;\n        }\n        const parent = collabNode._parent;\n        collabNode._normalized = true;\n        parent._xmlText.delete(offset, 1);\n        collabNodeMap.delete(nodeKey);\n        const parentChildren = parent._children;\n        const index = parentChildren.indexOf(collabNode);\n        parentChildren.splice(index, 1);\n      }\n    }\n  }\n  for (let i = 0; i < mergedNodes.length; i++) {\n    const [collabNode, text] = mergedNodes[i];\n    if (collabNode instanceof CollabTextNode && typeof text === 'string') {\n      collabNode._text = text;\n    }\n  }\n}\nfunction syncLexicalUpdateToYjs(binding, provider, prevEditorState, currEditorState, dirtyElements, dirtyLeaves, normalizedNodes, tags) {\n  syncWithTransaction(binding, () => {\n    currEditorState.read(() => {\n      // We check if the update has come from a origin where the origin\n      // was the collaboration binding previously. This can help us\n      // prevent unnecessarily re-diffing and possible re-applying\n      // the same change editor state again. For example, if a user\n      // types a character and we get it, we don't want to then insert\n      // the same character again. The exception to this heuristic is\n      // when we need to handle normalization merge conflicts.\n      if (tags.has('collaboration') || tags.has('historic')) {\n        if (normalizedNodes.size > 0) {\n          $handleNormalizationMergeConflicts(binding, normalizedNodes);\n        }\n        return;\n      }\n      if (dirtyElements.has('root')) {\n        const prevNodeMap = prevEditorState._nodeMap;\n        const nextLexicalRoot = $getRoot();\n        const collabRoot = binding.root;\n        collabRoot.syncPropertiesFromLexical(binding, nextLexicalRoot, prevNodeMap);\n        collabRoot.syncChildrenFromLexical(binding, nextLexicalRoot, prevNodeMap, dirtyElements, dirtyLeaves);\n      }\n      const selection = $getSelection();\n      const prevSelection = prevEditorState._selection;\n      syncLexicalSelectionToYjs(binding, provider, prevSelection, selection);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CONNECTED_COMMAND = createCommand('CONNECTED_COMMAND');\nconst TOGGLE_CONNECT_COMMAND = createCommand('TOGGLE_CONNECT_COMMAND');\nfunction createUndoManager(binding, root) {\n  return new UndoManager(root, {\n    trackedOrigins: new Set([binding, null])\n  });\n}\nfunction initLocalState(provider, name, color, focusing, awarenessData) {\n  provider.awareness.setLocalState({\n    anchorPos: null,\n    awarenessData,\n    color,\n    focusPos: null,\n    focusing: focusing,\n    name\n  });\n}\nfunction setLocalStateFocus(provider, name, color, focusing, awarenessData) {\n  const {\n    awareness\n  } = provider;\n  let localState = awareness.getLocalState();\n  if (localState === null) {\n    localState = {\n      anchorPos: null,\n      awarenessData,\n      color,\n      focusPos: null,\n      focusing: focusing,\n      name\n    };\n  }\n  localState.focusing = focusing;\n  awareness.setLocalState(localState);\n}\n\nexport { CONNECTED_COMMAND, TOGGLE_CONNECT_COMMAND, createBinding, createUndoManager, initLocalState, setLocalStateFocus, syncCursorPositions, syncLexicalUpdateToYjs, syncYjsChangesToLexical };\n"],
  "mappings": "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",
  "names": ["childKey"]
}
