{
  "version": 3,
  "sources": ["../../@lexical/mark/LexicalMark.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $isTextNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) {\n          return;\n        }\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if ($isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkNode };\n"],
  "mappings": "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",
  "names": []
}
