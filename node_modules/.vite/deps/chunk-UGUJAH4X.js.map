{
  "version": 3,
  "sources": ["../../@lexical/table/LexicalTable.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $isParagraphNode, $normalizeSelection__EXPERIMENTAL, $getNodeByKey, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $setSelection, SELECTION_CHANGE_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $getRoot, KEY_ARROW_DOWN_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, COMMAND_PRIORITY_CRITICAL, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    return $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined).setRowSpan(rowSpan).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = grid.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n        }\n        nodeMap.set(cell.getKey(), cell);\n        for (const child of $getChildrenRecursively(cell)) {\n          nodeMap.set(child.getKey(), child);\n        }\n        lastRow = currentRow;\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          $setSelection(this.tableSelection);\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = $createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      const cellNodes = selection.getNodes().filter($isTableCellNode);\n      const paragraph = cellNodes[0].getFirstChild();\n      const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n      cellNodes.forEach(cellNode => {\n        anchor.set(cellNode.getKey(), 0, 'element');\n        focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n        formatSelection.formatText(type, alignFormatWith);\n      });\n      $setSelection(selection);\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => deatatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove,\n      onMouseUp\n    };\n  };\n  const onMouseDown = event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n      editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n    }, 0);\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_BACKSPACE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_DELETE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction deatatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findMatchingParent(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = Object.freeze(colWidths) ;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const tableNode = $createTableNode();\n    tableNode.__rowStriping = serializedNode.rowStriping || false;\n    tableNode.__colWidths = serializedNode.colWidths;\n    return tableNode;\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined,\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    addClassNamesToElement(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (isHTMLElement(tableElement)) {\n            const cols = tableElement.querySelectorAll('col');\n            colGroup.append(...cols);\n            const rows = tableElement.querySelectorAll('tr');\n            tBody.append(...rows);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    this.getWritable().__rowStriping = newRowStriping;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      const width = col.style.width;\n      if (!width || !PIXEL_VALUE_REG_EXP.test(width)) {\n        columns = undefined;\n        break;\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableObserverFromTableElement };\n"],
  "mappings": "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",
  "names": []
}
