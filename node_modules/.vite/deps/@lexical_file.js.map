{
  "version": 3,
  "sources": ["../../@lexical/file/LexicalFile.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { CLEAR_HISTORY_COMMAND } from 'lexical';\n\nvar version = \"0.20.0\";\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Generates a SerializedDocument from the given EditorState\n * @param editorState - the EditorState to serialize\n * @param config - An object that optionally contains source and lastSaved.\n * source defaults to Lexical and lastSaved defaults to the current time in\n * epoch milliseconds.\n */\nfunction serializedDocumentFromEditorState(editorState, config = Object.freeze({})) {\n  return {\n    editorState: editorState.toJSON(),\n    lastSaved: config.lastSaved || Date.now(),\n    source: config.source || 'Lexical',\n    version\n  };\n}\n\n/**\n * Parse an EditorState from the given editor and document\n *\n * @param editor - The lexical editor\n * @param maybeStringifiedDocument - The contents of a .lexical file (as a JSON string, or already parsed)\n */\nfunction editorStateFromSerializedDocument(editor, maybeStringifiedDocument) {\n  const json = typeof maybeStringifiedDocument === 'string' ? JSON.parse(maybeStringifiedDocument) : maybeStringifiedDocument;\n  return editor.parseEditorState(json.editorState);\n}\n\n/**\n * Takes a file and inputs its content into the editor state as an input field.\n * @param editor - The lexical editor.\n */\nfunction importFile(editor) {\n  readTextFileFromSystem(text => {\n    editor.setEditorState(editorStateFromSerializedDocument(editor, text));\n    editor.dispatchCommand(CLEAR_HISTORY_COMMAND, undefined);\n  });\n}\nfunction readTextFileFromSystem(callback) {\n  const input = document.createElement('input');\n  input.type = 'file';\n  input.accept = '.lexical';\n  input.addEventListener('change', event => {\n    const target = event.target;\n    if (target.files) {\n      const file = target.files[0];\n      const reader = new FileReader();\n      reader.readAsText(file, 'UTF-8');\n      reader.onload = readerEvent => {\n        if (readerEvent.target) {\n          const content = readerEvent.target.result;\n          callback(content);\n        }\n      };\n    }\n  });\n  input.click();\n}\n\n/**\n * Generates a .lexical file to be downloaded by the browser containing the current editor state.\n * @param editor - The lexical editor.\n * @param config - An object that optionally contains fileName and source. fileName defaults to\n * the current date (as a string) and source defaults to Lexical.\n */\nfunction exportFile(editor, config = Object.freeze({})) {\n  const now = new Date();\n  const serializedDocument = serializedDocumentFromEditorState(editor.getEditorState(), {\n    ...config,\n    lastSaved: now.getTime()\n  });\n  const fileName = config.fileName || now.toISOString();\n  exportBlob(serializedDocument, `${fileName}.lexical`);\n}\n\n// Adapted from https://stackoverflow.com/a/19328891/2013580\nfunction exportBlob(data, fileName) {\n  const a = document.createElement('a');\n  const body = document.body;\n  if (body === null) {\n    return;\n  }\n  body.appendChild(a);\n  a.style.display = 'none';\n  const json = JSON.stringify(data);\n  const blob = new Blob([json], {\n    type: 'octet/stream'\n  });\n  const url = window.URL.createObjectURL(blob);\n  a.href = url;\n  a.download = fileName;\n  a.click();\n  window.URL.revokeObjectURL(url);\n  a.remove();\n}\n\nexport { editorStateFromSerializedDocument, exportFile, importFile, serializedDocumentFromEditorState };\n"],
  "mappings": ";;;;;;AAUA,IAAI,UAAU;AAiBd,SAAS,kCAAkC,aAAa,SAAS,OAAO,OAAO,CAAC,CAAC,GAAG;AAClF,SAAO;AAAA,IACL,aAAa,YAAY,OAAO;AAAA,IAChC,WAAW,OAAO,aAAa,KAAK,IAAI;AAAA,IACxC,QAAQ,OAAO,UAAU;AAAA,IACzB;AAAA,EACF;AACF;AAQA,SAAS,kCAAkC,QAAQ,0BAA0B;AAC3E,QAAM,OAAO,OAAO,6BAA6B,WAAW,KAAK,MAAM,wBAAwB,IAAI;AACnG,SAAO,OAAO,iBAAiB,KAAK,WAAW;AACjD;AAMA,SAAS,WAAW,QAAQ;AAC1B,yBAAuB,UAAQ;AAC7B,WAAO,eAAe,kCAAkC,QAAQ,IAAI,CAAC;AACrE,WAAO,gBAAgB,uBAAuB,MAAS;AAAA,EACzD,CAAC;AACH;AACA,SAAS,uBAAuB,UAAU;AACxC,QAAM,QAAQ,SAAS,cAAc,OAAO;AAC5C,QAAM,OAAO;AACb,QAAM,SAAS;AACf,QAAM,iBAAiB,UAAU,WAAS;AACxC,UAAM,SAAS,MAAM;AACrB,QAAI,OAAO,OAAO;AAChB,YAAM,OAAO,OAAO,MAAM,CAAC;AAC3B,YAAM,SAAS,IAAI,WAAW;AAC9B,aAAO,WAAW,MAAM,OAAO;AAC/B,aAAO,SAAS,iBAAe;AAC7B,YAAI,YAAY,QAAQ;AACtB,gBAAM,UAAU,YAAY,OAAO;AACnC,mBAAS,OAAO;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACD,QAAM,MAAM;AACd;AAQA,SAAS,WAAW,QAAQ,SAAS,OAAO,OAAO,CAAC,CAAC,GAAG;AACtD,QAAM,MAAM,oBAAI,KAAK;AACrB,QAAM,qBAAqB,kCAAkC,OAAO,eAAe,GAAG;AAAA,IACpF,GAAG;AAAA,IACH,WAAW,IAAI,QAAQ;AAAA,EACzB,CAAC;AACD,QAAM,WAAW,OAAO,YAAY,IAAI,YAAY;AACpD,aAAW,oBAAoB,GAAG,QAAQ,UAAU;AACtD;AAGA,SAAS,WAAW,MAAM,UAAU;AAClC,QAAM,IAAI,SAAS,cAAc,GAAG;AACpC,QAAM,OAAO,SAAS;AACtB,MAAI,SAAS,MAAM;AACjB;AAAA,EACF;AACA,OAAK,YAAY,CAAC;AAClB,IAAE,MAAM,UAAU;AAClB,QAAM,OAAO,KAAK,UAAU,IAAI;AAChC,QAAM,OAAO,IAAI,KAAK,CAAC,IAAI,GAAG;AAAA,IAC5B,MAAM;AAAA,EACR,CAAC;AACD,QAAM,MAAM,OAAO,IAAI,gBAAgB,IAAI;AAC3C,IAAE,OAAO;AACT,IAAE,WAAW;AACb,IAAE,MAAM;AACR,SAAO,IAAI,gBAAgB,GAAG;AAC9B,IAAE,OAAO;AACX;",
  "names": []
}
